//-*-C++-*-

/*
  ________  _________     _____
  \______ \ \_   ___ \   /  _  \      .__
  |    |  \/    \  \/  /  /_\  \   __|  |___
  |    `   \     \____/    |    \ /__    __/
  /_______  /\______  /\____|__  /    |__|
  \/        \/         \/

  __________        __                   _________ __
  \______   \ _____/  |_  ___________   /   _____//  |______  _____ _______
  |     ___// __ \   __\/ __ \_  __ \  \_____  \\   __\__  \ \__  \\_  __ \
  |    |   \  ___/|  | \  ___/|  | \/  /        \|  |  / __ \_/ __ \|  | \/
  |____|    \___  >__|  \___  >__|    /_______  /|__| (____  (____  /__|
  \/          \/                \/           \/     \/
  _________________________ ___   __________            .__       .__
  \_   _____/\__    ___/   |   \  \____    /__ _________|__| ____ |  |__
  |    __)_   |    | /    ~    \   /     /|  |  \_  __ \  |/ ___\|  |  \
  |        \  |    | \    Y    /  /     /_|  |  /|  | \/  \  \___|   Y  \
  /_______  /  |____|  \___|_  /  /_______ \____/ |__|  |__|\___  >___|  /
  \/                 \/           \/                    \/     \/
*/

#include "compiler_directives.h"

#include "include_files.h"

CUDA_FUNCTION

std::string get_version()
{
  string str("DEFAULT");
  return str;
}

void print_version()
{
  string str = get_version();

  cout << "\n\n\n";
  cout << "*************************************************************************************\n";
  cout << "***                                  VERSION                                      ***\n";
  cout << "*************************************************************************************\n";
  cout << "\n\n\n";

  cout << str << endl;
}

INITIALIZE_MAGMA_0;

int main(int argc,char *argv[])
{
  if(argc < 2)
    {
      std::cout << "Usage: "<<argv[0]<<" inputFileName\n";
      return -1;
    }

  std::string file_name(argv[1]);

  // ============================================================ Configure the calculation by selecting type definitions.

#include "type_definitions.h"

  static const LIN_ALG ::device_type                   LIN_ALG_DEVICE               = LIN_ALG_DEVICE_TYPE;
  static const DCA     ::CLUSTER_SOLVER_NAMES          CLUSTER_SOLVER_NAME          = CLUSTER_SOLVER_TYPE;
  //static const DCA     ::CLUSTER_SOLVER_NAMES          CLUSTER_SOLVER_NAME          = DCA::SS_CT_HYB;
  static const COMP_LIB::PARALLELIZATION_LIBRARY_NAMES PARALLELIZATION_LIBRARY_NAME = PARALLELIZATION_LIBRARY_TYPE;

  typedef COMP_LIB::parallelization<PARALLELIZATION_LIBRARY_NAME>  concurrency_type;
  typedef Parameters<concurrency_type, model, CLUSTER_SOLVER_NAME> parameters_type;

  typedef DCA::DCA_data<parameters_type>                  MOMS_type;
  //typedef MultiOrbitalMultiSiteStructure<parameters_type> MOMS_type;

  typedef DCA::cluster_solver<CLUSTER_SOLVER_NAME, LIN_ALG_DEVICE, parameters_type, MOMS_type> quantum_cluster_solver_type;

  //typedef quantum_cluster_solver_type                             Monte_Carlo_Integrator_type;
  //typedef DCA::posix_qmci_integrator<quantum_cluster_solver_type> Monte_Carlo_Integrator_type;

  typedef DCA::DCA_calculation<parameters_type, MOMS_type, Monte_Carlo_Integrator_type> DCA_calculation_type;

  // ====================================================================== Create the algorithms and parameters object from the input file

  concurrency_type concurrency(argc, argv);

  parameters_type::profiler_type::start();

  std::string stamp = get_version();

  if(concurrency.id() == concurrency.first())
    {
      cout << "DCA main: starting (MPI-world set up).\n\n";

      print_device_info();

      print_version();
    }

  INITIALIZE_MAGMA_1;

  parameters_type parameters(stamp, concurrency);

  parameters.read_input_and_broadcast(file_name);

  parameters.update_model();
  parameters.update_domains();

  MOMS_type MOMS(parameters);
  MOMS.initialize();

  DCA_calculation_type dca_object(parameters, MOMS, concurrency);

  {
    parameters_type::profiler_type profiler(__FUNCTION__, __FILE__, __LINE__);

    dca_object.initialize();

    dca_object.execute();
      
    dca_object.finalize();

    //dca_object.iterate_to_consistency_2();
  }

  parameters_type::profiler_type::stop(concurrency, parameters.get_profiling_file_name());

  if(concurrency.id() == concurrency.last())
    {
      cout << "\n\n\t\t --> processor " << concurrency.id() << " is writing data " << endl;
      dca_object.write();
    }

  if(concurrency.id() == concurrency.last())
    cout << "\n\nDCA main: ending. \n\n";

  return 0;
}
