\documentclass[a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage{xcolor}
\definecolor{DarkRed}{rgb}{0.6,0,0.1}

\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{amsmath, amsthm, amssymb}
\usepackage[colorlinks=true, linkcolor=DarkRed]{hyperref}
\usepackage{listings}

\setlength\parindent{0pt}
\setlength\parskip{2pt}

\definecolor{DarkBlue}{rgb}{0,0,0.5}

\lstset {
    language=C++,
    %backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\small\ttfamily,
    keywordstyle=\bf\color{DarkBlue},
    commentstyle=\color{magenta},
    otherkeywords={Type,Type1,Type2,Type3},
    keepspaces=true,
    showspaces=true,
}

\newcommand{\inlinecode}[1]{\lstinline|#1|}
%\newcommand{\TODO}[1]{{\color{red}\textbf{#1}}}

\begin{document}

\tableofcontents

\section{Files}
Each file should contain the header included in \inlinecode{HEADER.TXT}, and the author of the file.
The header should also provide a description of the content of the file.
If you make significant changes to a file consider adding your name to the author list.

\subsection{File organization}
Each class should be defined a different file, whose name is the class name where the upper case letters are replaced with a underscore (\inlinecode{_}) and the lower case letter.i (Exception: if the upper case letter is the first letter, no underscore is prepended).

Header files should be placed in \verb|include/dca/|, source files in \verb|src/|. Tests should be placed in \verb|test/unit/|, \verb|test/integration/|, \verb|test/system-level/| or \verb|test/performance/| according to their type. \verb|include/dca/|, \verb|src/| and \verb|test/unit/| should have the same tree structure.

\subsection{File Names}
Filenames should be all lowercase and can include numbers and underscores (\inlinecode{_}). Uppercase are allowed for abbreviations and chemical compounds.
Header files use the extension \verb|.hpp|, while source files use the extension \verb|.cpp|.

The filenames of the tests are composed by the filename of the object tested and the suffix \inlinecode{_test} is appended.
The filename of fake objects used in tests are composed by the prefix \inlinecode{mock_} and the filename of the object that is replaced.

\subsection{Header files}
All header files should be self-contained. This means that each header can be included without defining anything special.
In particular each header file should include all the headers needed and have \inlinecode{\#define} guards to prevent multiple inclusion.

If a template or inline function is declared in a \verb|.hpp| file, the function has to be defined in the same file.

The symbol name of the \inlinecode{\#define} guards should be \inlinecode{PATH_FILENAME_HPP}, where \inlinecode{PATH} is based on the \verb|include| directory. For example, the file\\ \verb|dca_ethz/include/dca/foo/bar.hpp| should have the following guard:

\begin{lstlisting}
#ifndef DCA_FOO_BAR_HPP
#define DCA_FOO_BAR_HPP
...
#endif  // DCA_FOO_BAR_HPP
\end{lstlisting}

\subsection{Includes}
Header files should be included with the full path based on the \verb|include| directory. For example, the file \verb|dca_ethz/include/dca/foo/bar.hpp| should be included as
\begin{lstlisting}
#include "dca/foo/bar.hpp"
\end{lstlisting}
Even if the included file is located in the same directory as the including file this rule should be obeyed. \\

For readability it is suggested to use the standard order of includes:
\begin{enumerate}
	\item Related header
	\item C library
	\item C++ library
	\item Other libraries' .h
	\item Your project's .h
\end{enumerate}
In each section the included files should be sorted in alphabetical order.
\section{Naming}

The names should be as descriptive as possible.

\subsection{Type and Class Names}

Type and class names should start with an uppercase character and should have a capital letter for each new word. Underscores (\inlinecode{_}) are not allowed.

The \inlinecode{using} syntax is preferred to \inlinecode{typedef} for type definitions.

\subsection{Namespace Names}

Namespace names should be one word, lowercase.

\subsection{Variable Names}

\subsubsection{Variable Names}

Variable names should contain only lowercase characters and underscores (\inlinecode{_}). The underscore is not allowed as first or last character.

\subsubsection{Class Data Members}

Class data members names follows the convention of variable names with a trailing underscore (\inlinecode{_}).

\subsection{Function Names}

Function names should start with a lowercase character and should have a capital letter for each new word. Underscores (\inlinecode{_}) are not allowed.

\subsection{Macro Names}

Macro names should be all uppercase and can include underscores (\inlinecode{_}). The underscore is not allowed as first or last character.

\section{Comments}

\subsection{Comment Style}

Use the \inlinecode{// Comment} syntax. The \inlinecode{/* ... */} syntax is allowed only for unused variables in function declarations.

\subsection{Function Comments}

Each function, whose name does not fully describe the operations performed should have comments that describe what the function does.

For function parameters whose type is non-const reference or pointer to non-const memory,
it should be specified if they are input (In:), output (Out:) or input-output parameters (InOut:).

Example:
\begin{lstlisting}
// Updates foo and computes bar using in_1 .. in_5.
// In: in_3, in_5
// InOut: foo
// Out: bar
void computeFooBar(Type in_1, const Type& in_2, Type& in_3,
                   const Type* in_4, Type* in_5, Type& foo,
                   Type& bar);
\end{lstlisting}

\subsection{Variable Comments}

No comments, since the name should be self-descriptive.

\subsection{Class Comments}

Every class should have a short description of what it is and what is does.
Comments for public class member functions follow the same rules as general function comments.
Comments for private members are allowed, but not mandatory.

\subsection{Implementation Comments}

Tricky, complicated or important code blocks should have comments before them.
Line comments should be separated from the code by 2 spaces. If multiple subsequent lines have a comment they should be aligned.

Example:
\begin{lstlisting}
statement;        // Comment here so the comments line up.
longerstatement;  // Two spaces between code and comment.
\end{lstlisting}

If you modify a piece of code, also adapt the comments that belong to it if necessary.

\subsection{Comments excluded in releases}

Comments formatted as \inlinecode{// TODO: Comment}, \inlinecode{// INTERNAL: Comment} and \inlinecode{// REVIEW: Comment} are removed in the releases.

\subsection{Punctuation, Spelling and Grammar}

Pay attention to correct punctuation, spelling, and grammar. This will improve the clarity and readability of the comments.

\section{Formatting}

Use the provided clang-format style to format \verb|.hpp| and \verb|.cpp| files.

\subsection{Line Length}

The length of each line of your code should, in principle, be at most 100 characters. This limit can be exceeded by few characters in special cases.

\subsection{Scopes}

Do not use scopes for formatting reason.

\subsection{Horizontal Spacing}

No trailing whitespaces should be added to any line.
Use no space before a comma (\inlinecode{,}) and a semicolon (\inlinecode{;}) and add a space after them if they are not at the end of a line.

\subsubsection{Parenthesis}

Parenthesis should have no internal padding, and one space external padding.
The one space external padding is not allowed in the following cases:
\begin{itemize} \itemsep -3pt
 \vspace{-2ex}
 \item between two opening of two closing parenthesis,
 \item between the function name and its arguments,
 \item between a closing parenthesis and a comma (\inlinecode{,}) or a semicolon (\inlinecode{;}).
\end{itemize}

\subsubsection{Binary Operators}

The assignment operator should always have spaces around it. Other operators may have spaces around them, but is not mandatory.

\subsubsection{Unary Operators}

Do not put any space between the unary operator and their argument.

\subsubsection{Types}

The angle brackets of the templates should not have any external and internal padding.
(However, for \texttt{C++03} codes the space between two closing angle brackets is mandatory.)

Examples:
\begin{lstlisting}
type* var;
type& var;

Class1<Class2<type1>> object;  // OK with C++11, does not
                               // compile with C++03.
\end{lstlisting}

\subsection{Vertical Spacing}

Use empty lines when it helps the readability of the code, but do not use too many.
Do not use empty lines after a brace which opens a scope,
or before a brace which closes a scope.
Each file should contain an empty line at the end of the file (Some editors add an empty line automatically, some do not) .

\subsection{Indentation}

Indentation consists of 2 spaces. Don't use tabs in the code.

\subsection{Function Declarations and Definitions}

The return type should be in the same line as the function name, and the parameters should be on the same line unless they don't fit in it.
Add the parameters name also in the declaration of a function and avoid
\begin{lstlisting}
Type Function(Type1, Type2, Type3);
\end{lstlisting}
In function declarations comment the unused parameter names. \\(E.g. \inlinecode{Type /* unused_parameter_name */})

Examples:
\begin{lstlisting}
Type Class::Function(Type1 par1, Type2 par2) {
  statement;
  ...
}

Type LongNameClass::LongNameFunction(Type1 par1, Type2 par2
                                     Type3 par3) {
  statement;
  ...
}
\end{lstlisting}

% For formatting purpose, can be removed.
\vspace{3em}

In case of a long list of parameters prefer
\begin{lstlisting}
Type LongNameClass::LongNameFunction(
    Type1 long_name_par1, Type2 long_name_par2,Type3 par3) {
  statement;
  ...
}
\end{lstlisting}
to
\begin{lstlisting}
Type LongNameClass::LongNameFunction(Type1 long_name_par1,
                                     Type2 long_name_par2,
                                     Type3 par3) {
  statement;
  ...
}
\end{lstlisting}

\subsection{Function Calls}

Write the call all on a single line, if the length of the line doesn't exceed the maximum limit.
If not possible, wrap the arguments at the parenthesis, or start the arguments on a new line using 4 spaces indent.
Use the method which uses the smaller amount of lines.

Examples:
\begin{lstlisting}
Function(par1, par2, par3);

Function(par1, par2,
         par3);

Function(
    par1, par2, par3);
\end{lstlisting}

\subsection{Conditionals}

Examples:
\begin{lstlisting}
if (condition)
  statement;
else
  statement;

if (condition) {
  statement;
}
else if (condition2) {
  statement;
}
else {
  statement;
}
\end{lstlisting}

\subsection{Switch statement}

Switch statements should always have a default case.

Example
\begin{lstlisting}
switch (var) {
  case 0:
    statement1;
    statement2;
    break;

  case 1:
    statement1;
    statement2;
    break;

  default:
    statement1;
    statement2;
}
\end{lstlisting}

\subsection{Loops}

Examples:
\begin{lstlisting}
for (statement; condition; statement)
  statement;

for (statement; condition; statement) {
  statement1;
  statement2;
}

while (condition)
  statement;

while (condition) {
  statement1;
  statement2;
}

do {
  statement;
}
while (condition);
\end{lstlisting}

\subsection{Preprocessor Directives}

The preprocessor directives are not indented. The hash is the first character of the line.

\subsection{Class Format}

Public, protected and private keywords are not indented.

Example:
\begin{lstlisting}
class Foo : public Bar {
public:
  Foo();
  explicit Foo(int var);

  void function();
  void emptyFunction() {}

  void setVar(int var) {
    var_ = var;
  }
  int getVar() const {
    return var_;
  }

private:
  bool privateFunction();

  int var_;
  int var2_;
};
\end{lstlisting}

\subsubsection{Constructor Initializer Lists}

Examples:
\begin{lstlisting}
// When everything fits on one line:
Foo::Foo(int var) : var_(var) {
  statement;
}

// If the signature and the initializer list do not
// fit on one line, the colon is indented by 4 spaces:
Foo::Foo(int var)
    : var_(var), var2_(var + 1) {
  statement;
}

// If the initializer list occupies more lines
// they are aligned in the following way:
Foo::Foo(int var)
    : some_var_(var),
      some_other_var_(var + 1) {
  statement;
}

// No statements:
Foo::Foo(int var)
    : some_var_(var) {}
\end{lstlisting}

\subsection{Namespace Formatting}

The content of namespaces is not indented.
If nested namespaces are used a comment with the full namespace is required after each set of namespace declaration,
and when a namespace is closed a comment should indicate which namespace is closed.

Example:
\begin{lstlisting}
namespace ns{
void foo();
}

namespace ns1{
namespace ns2{
// ns1::ns2::
void foo();

namespace ns3{
// ns1::ns2::ns3::
void bar();
}  // ns3
}  // ns2

namespace ns4{
namespace ns5{
// ns1::ns4::ns5::
void foo();
}  // ns5
}  // ns4
}  // ns1
\end{lstlisting}

\end{document}
