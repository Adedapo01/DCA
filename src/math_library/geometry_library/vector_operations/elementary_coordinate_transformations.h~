//-*-C++-*-

#ifndef ELEMENTARY_COORDINATE_TRANSFORMATION_H
#define ELEMENTARY_COORDINATE_TRANSFORMATION_H

/*!
 *  \ingroup ALGORITHMS
 *
 *  \author  Peter Staar
 */
namespace VECTOR_OPERATIONS
{
  template<typename scalartype>
  class COORDINATES
  {
  public:

    static void execute(scalartype* v0, scalartype* v1                , scalartype* vec, scalartype* coor); 
    static void execute(scalartype* v0, scalartype* v1, scalartype* v2, scalartype* vec, scalartype* coor); 

    static void execute(std::vector<scalartype>& v0, std::vector<scalartype>& v1                             , std::vector<scalartype>& vec, std::vector<scalartype>& coor); 
    static void execute(std::vector<scalartype>& v0, std::vector<scalartype>& v1, std::vector<scalartype>& v2, std::vector<scalartype>& vec, std::vector<scalartype>& coor);

    COORDINATES(int d);
    ~COORDINATES();

    // basis-vectors column-wise
    void set_basis(scalartype* basis);

    // basis-vectors column-wise
    void set_basis(std::vector<std::vector<scalartype> >& basis);

    void execute(scalartype* vec, scalartype* coor);

  private:

    int DIMENSION;

    LIN_ALG::matrix<scalartype, LIN_ALG::CPU> T;
    LIN_ALG::matrix<scalartype, LIN_ALG::CPU> T_inv;
  };

  template<typename scalartype>
  void COORDINATES<scalartype>::execute(scalartype* v0, 
				       scalartype* v1,
				       scalartype* vec,
				       scalartype* coor) 
  { 
    LIN_ALG::matrix<scalartype, LIN_ALG::CPU> A("A", 2);
    
    A(0,0) = v0[0];
    A(1,0) = v0[1];
    
    A(0,1) = v1[0];
    A(1,1) = v1[1];
    
    LIN_ALG::GEINV<LIN_ALG::CPU>::execute(A);
    
    coor[0] = A(0,0)*vec[0] + A(0,1)*vec[1];  
    coor[1] = A(1,0)*vec[0] + A(1,1)*vec[1]; 
  }
  
  template<typename scalartype>
  void COORDINATES<scalartype>::execute(std::vector<scalartype>& v0, 
					std::vector<scalartype>& v1,
					std::vector<scalartype>& vec,
					std::vector<scalartype>& coor) 
  { 
    assert(v0.size()==2);
    assert(v1.size()==2);
    assert(vec.size()==2);
    assert(coor.size()==2);
    
    execute(&v0[0], &v1[0], &vec[0], &coor[0]);
  }
  
  template<typename scalartype>
  void COORDINATES<scalartype>::execute(scalartype* v0, 
					scalartype* v1,
					scalartype* v2,
					scalartype* vec,
					scalartype* coor) 
  { 
    LIN_ALG::matrix<scalartype, LIN_ALG::CPU> A("A", 3);
    
    A(0,0) = v0[0];
    A(1,0) = v0[1];
    A(2,0) = v0[2];
    
    A(0,1) = v1[0];
    A(1,1) = v1[1];
    A(2,1) = v1[2];
    
    A(0,2) = v2[0];
    A(1,2) = v2[1];
    A(2,2) = v2[2];
    
    LIN_ALG::GEINV<LIN_ALG::CPU>::execute(A);
    
    coor[0] = A(0,0)*vec[0] + A(0,1)*vec[1] + A(0,2)*vec[2];  
    coor[1] = A(1,0)*vec[0] + A(1,1)*vec[1] + A(1,2)*vec[2];  
    coor[2] = A(2,0)*vec[0] + A(2,1)*vec[1] + A(2,2)*vec[2];  
  }
  
  template<typename scalartype>
  void COORDINATES<scalartype>::execute(std::vector<scalartype>& v0, 
					std::vector<scalartype>& v1,
					std::vector<scalartype>& v2,
					std::vector<scalartype>& vec,
					std::vector<scalartype>& coor) 
  { 
    assert(v0.size()==3);
    assert(v1.size()==3);
    assert(v2.size()==3);
    assert(vec.size()==3);
    assert(coor.size()==3);
    
    execute(&v0[0], &v1[0], &v2[0], &vec[0], &coor[0]);
  }
    

  template<typename scalartype>
  COORDINATES<scalartype>::COORDINATES(int d):
    DIMENSION(d),
    T    ("T"    , d),
    T_inv("T_inv", d)
  {}
  
  template<typename scalartype>
  COORDINATES<scalartype>::~COORDINATES()
  {}
  
  template<typename scalartype>
  void COORDINATES<scalartype>::set_basis(scalartype* basis)
  {
    for(int d1=0; d1<DIMENSION; d1++)
      for(int d0=0; d0<DIMENSION; d0++)
	T(d0,d1) = basis[d0+d1*DIMENSION];
    
    T_inv.copy_from(T);

    LIN_ALG::GEINV<LIN_ALG::CPU>::execute(T_inv);
  }
  
  template<typename scalartype>
  void COORDINATES<scalartype>::set_basis(std::vector<std::vector<scalartype> >& basis)
  {
    set_basis(basis[0][0]);
  }
  
  template<typename scalartype>
  void COORDINATES<scalartype>::execute(scalartype* vec, scalartype* coor)
  {
    switch(DIMENSION)
      {
      case 1:
	coor[0] = T_inv(0,0)*vec[0];
	break;

      case 2:
	coor[0] = T_inv(0,0)*vec[0]+T_inv(0,1)*vec[1];
	coor[1] = T_inv(1,0)*vec[0]+T_inv(1,1)*vec[1];
	break;

      case 3:
	coor[0] = T_inv(0,0)*vec[0]+T_inv(0,1)*vec[1]+T_inv(0,2)*vec[2];
	coor[1] = T_inv(1,0)*vec[0]+T_inv(1,1)*vec[1]+T_inv(1,2)*vec[2];
	coor[2] = T_inv(2,0)*vec[0]+T_inv(2,1)*vec[1]+T_inv(2,2)*vec[2];
	break;
	
      default:

	for(int d0=0; d0<DIMENSION; d0++)
	  coor[0] = 0;

	for(int d1=0; d1<DIMENSION; d1++)
	  for(int d0=0; d0<DIMENSION; d0++)
	    coor[d0] += T_inv(d0,d1)*vec[d1];
      }
  }

}

#endif
