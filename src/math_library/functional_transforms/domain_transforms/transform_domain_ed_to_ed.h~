//-*-C++-*-

#ifndef BASIS_TRANSFORMATIONS_ED_TO_ED_H
#define BASIS_TRANSFORMATIONS_ED_TO_ED_H

namespace TRAFOR
{
  template<typename type_input, typename type_output,int DMN_INDEX>
  class TRANSFORM_DOMAIN<type_input, EXPANSION, type_output, EXPANSION, DMN_INDEX>
  {
  private:

    const static bool VERBOSE = false;

    typedef basis_transformation<type_input, EXPANSION, type_output, EXPANSION> basis_transformation_type;
    typedef typename basis_transformation_type::matrix_type                     matrix_type;

  public:
    
    template<typename scalartype_input, class domain_input, 
	     typename scalartype_output, class domain_output>
    static void execute(function<scalartype_input , domain_input >& f_input, 
			function<scalartype_output, domain_output>& f_output);

    template<typename scalartype, class domain_input, class domain_output>
    static void execute(function<scalartype, domain_input >& f_input, 
			function<scalartype, domain_output>& f_output)
    {
      if(VERBOSE)
	cout << "\n\t inverse transform (expansion -> expansion) " << DMN_INDEX << "  " << type_input::get_name() << " --> " << type_output::get_name() << "\n\n";
      
      int M, K, N, P;
      characterize_transformation(f_input, f_output, M, K, N, P);

      matrix_type& T = basis_transformation_type::get_transformation_matrix();

      for(int l=0; l<P; l++)
	{
	  int lin_ind_lhs = M*K*l;
	  int lin_ind_rhs = M*N*l;

	  LIN_ALG::GEMM<LIN_ALG::CPU>::execute('N', 'T', M, N, K,
					       scalartype(1),
					       &f_input(lin_ind_lhs), M,
					       &T(0,0)              , T.get_global_size().first,
					       scalartype(0),
					       &f_output(lin_ind_rhs), M);
	}
    }

  private:
 
    template<typename f_input_t, typename f_output_t>
    static void characterize_transformation(f_input_t& f_input, f_output_t f_output, int& M, int& K, int& N, int& P)
    {
      M = 1;
      for(int l=0; l<DMN_INDEX; l++)
	M *= f_input[l];
      
      K = f_input [DMN_INDEX];
      N = f_output[DMN_INDEX];
      
      P = 1;
      for(int l=DMN_INDEX+1; l<f_input.signature(); l++)
	P *= f_input[l];
    }
    
  };

}

#endif
