//-*-C++-*-

#ifndef BASIS_TRANSFORMATION_H
#define BASIS_TRANSFORMATION_H

namespace TRAFOR
{
  /*! 
   *  \ingroup 
   *
   *  \brief  
   *  \author Peter Staar
   *
   *  \version 1.0
   *  \date    2013
   */
  template<typename input_type , DOMAIN_REPRESENTATION_type DMN_REP_INPUT,
	   typename output_type, DOMAIN_REPRESENTATION_type DMN_REP_OUTPUT>
  class basis_transformation
  {
  public:

    typedef input_type  rh_dmn_type;
    typedef output_type lh_dmn_type;

    typedef typename lh_dmn_type::dmn_specifications_type lh_spec_dmn_type;
    typedef typename rh_dmn_type::dmn_specifications_type rh_spec_dmn_type;

    typedef typename lh_spec_dmn_type::scalar_type lh_scalar_type;
    typedef typename rh_spec_dmn_type::scalar_type rh_scalar_type;

    typedef typename lh_spec_dmn_type::element_type lh_element_type;
    typedef typename rh_spec_dmn_type::element_type rh_element_type;

    typedef basis_function<lh_dmn_type, rh_dmn_type, rh_spec_dmn_type::basis_expansion> basis_function_type;

    typedef typename basis_function_type::f_scalar_type f_scalar_type;

    //typedef function<f_scalar_type, lh_dmn_type>         function_type;
    typedef LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU> matrix_type;

  public:

    static bool& is_initialized()
    {
      static bool initialized = false;
      return initialized;
    }
    
    static std::string& get_name()
    {
      static std::string name = "basis-transformation";
      return name;
    }

    static LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU>& get_transformation_matrix()
    {
      static bool initialized = false;

      static LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU> T;

      if(not initialized)
	{
	  initialized = true;

	  initialize_transformation_matrix();
	}

      return T;
    }

    static LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU>& get_inverse_transformation_matrix()
    {
      static bool initialized = false;

      static LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU> T_inv;

      if(not initialized)
	{
	  initialized = true;

	  initialize_inverse_transformation_matrix();
	}

      return T_inv;
    }

    static void initialize_transformation_matrix()
    {
      int M = lh_dmn_type::get_size();
      int N = rh_dmn_type::get_size();

      assert(M>0 and N>0);
 
      LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU>& T = get_transformation_matrix();
      
      T.reserve(std::pair<int, int>(M, N));
      
      for(int j=0; j<N; j++)
	for(int i=0; i<M; i++)
	  T(i,j) = basis_function_type::execute(i,j);
    }

    static void initialize_inverse_transformation_matrix()
    {
      int M = lh_dmn_type::get_size();
      int N = rh_dmn_type::get_size();

      assert(M>0 and N>0);

      LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU>& T     = get_transformation_matrix();
      
      LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU>& T_inv = get_inverse_transformation_matrix();

      T_inv.reserve(std::pair<int, int>(N, M));

      LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU> U ("U" , std::pair<int, int>(M, M));
      LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU> VT("VT", std::pair<int, int>(N, N));

      LIN_ALG::vector<lh_scalar_type, LIN_ALG::CPU> S("S", min(M, N));

      LIN_ALG::GESVD<LIN_ALG::CPU>::execute('A', T, S, U, VT);

      if(true)
	{
	  LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU> A("A", std::pair<int, int>(M, N));
	  
	  //A.copy_from(T);
	  for(int i=0; i<M; i++)
	    for(int j=0; j<N; j++)
	      for(int k=0; k<min(M,N); k++)
		A(i,j) += U(i,k)*S[k]*VT(k,j);
	  
	  T.print();
	  A.print();
	}
      
      {
	U .print();
	VT.print();
	S .print();

	for(int i=0; i<M; i++)
	  for(int j=0; j<M; j++)
	    T_inv(i,j) = 0;

	for(int i=0; i<N; i++)
	  for(int j=0; j<M; j++)
	    for(int k=0; k<min(M,N); k++)
	      if(abs(S[k])>1.e-6)
		T_inv(i,j) += conjugate(VT(k,i))/S[k]*conjugate(U(j,k));      
	
	T_inv.print();
	assert(false);
      }

      if(true)
	{
	  LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU> I("I", std::pair<int, int>(M, M));

// 	  for(int i=0; i<M; i++)
// 	    for(int j=0; j<M; j++)
// 	      I(i,j)=0;

	  for(int i=0; i<M; i++)
	    for(int j=0; j<M; j++)
	      for(int k=0; k<N; k++)
		I(i,j) += T(i,k)*T_inv(k,j);
	  
	  I.print();
	}
      
      if(true)
	{
	  LIN_ALG::matrix<f_scalar_type, LIN_ALG::CPU> I("I", std::pair<int, int>(N, N));
	  
// 	  for(int i=0; i<N; i++)
// 	    for(int j=0; j<N; j++)
// 	      I(i,j)=0;

	  for(int i=0; i<N; i++)
	    for(int j=0; j<N; j++)
	      for(int k=0; k<M; k++)
		I(i,j) += T_inv(i,k)*T(k,j);
	  
	  I.print();
	}
    }

  private:

    template<typename scalartype>
    static scalartype conjugate(scalartype x)
    {
      return x;
    }

    template<typename scalartype>
    static std::complex<scalartype> conjugate(std::complex<scalartype> x)
    {
      return std::conj(x);
    }

  };

}

#endif
