//-*-C++-*-

#ifndef GAUSSIAN_FIT_H
#define GAUSSIAN_FIT_H

namespace MATH_LIBRARY
{
  template<typename scalar_type, typename K_dmn_t, typename k_dmn_t>
  class gaussian_fit
  {
    const static int DIMENSION = K_dmn_t::parameter_type::DIMENSION;

    typedef typename K_dmn_t::parameter_type::element_type K_element_type;
    typedef typename k_dmn_t::parameter_type::element_type k_element_type;

  public:

    typedef LIN_ALG::matrix<scalar_type, LIN_ALG::CPU> matrix_type;

  public:

    gaussian_fit();
    ~gaussian_fit();

    matrix_type& get_interpolation_matrix();
    matrix_type& get_correlation_matrix  ();

    template<typename covariance_type>
    void initialize(covariance_type& covariance, double error);

    template<typename covariance_type>
    void initialize_interpolation_matrix(covariance_type& covariance, double error);

    template<typename covariance_type>
    void initialize_correlation_matrix  (covariance_type& covariance, double error);

  private:

    std::vector<scalar_type> length_scale;

    matrix_type interpolation_matrix;
    matrix_type correlation_matrix;
  };

  template<typename scalar_type, typename K_dmn_t, typename k_dmn_t>
  gaussian_fit<scalar_type, K_dmn_t, k_dmn_t>::gaussian_fit():
    length_scale(DIMENSION, 1.),

    interpolation_matrix("interpolation_matrix"),
    correlation_matrix  ("correlation_matrix")
  {}

  template<typename scalar_type, typename K_dmn_t, typename k_dmn_t>
  gaussian_fit<scalar_type, K_dmn_t, k_dmn_t>::~gaussian_fit()
  {}

  template<typename scalar_type, typename K_dmn_t, typename k_dmn_t>
  LIN_ALG::matrix<scalar_type, LIN_ALG::CPU>& gaussian_fit<scalar_type, K_dmn_t, k_dmn_t>::get_interpolation_matrix()
  {
    return interpolation_matrix;
  }

  template<typename scalar_type, typename K_dmn_t, typename k_dmn_t>
  LIN_ALG::matrix<scalar_type, LIN_ALG::CPU>& gaussian_fit<scalar_type, K_dmn_t, k_dmn_t>::get_correlation_matrix()
  {
    return correlation_matrix;
  }

  template<typename scalar_type, typename K_dmn_t, typename k_dmn_t>
  template<typename covariance_type>
  void gaussian_fit<scalar_type, K_dmn_t, k_dmn_t>::initialize(covariance_type& covariance, double error)
  {
    initialize_interpolation_matrix(covariance, error);

    initialize_correlation_matrix(covariance, error);
  }

  template<typename scalar_type, typename K_dmn_t, typename k_dmn_t>
  template<typename covariance_type>
  void gaussian_fit<scalar_type, K_dmn_t, k_dmn_t>::initialize_interpolation_matrix(covariance_type& covariance, double error)
  {
    int N_r = k_dmn_t::dmn_size();
    int N_c = K_dmn_t::dmn_size();

    interpolation_matrix.resize_no_copy(std::pair<int,int>(N_r, N_c));

    LIN_ALG::matrix<scalar_type, LIN_ALG::CPU> K_K("K_K", std::pair<int,int>(N_c, N_c));

    for(int i=0; i<N_c; i++){
      for(int j=0; j<N_c; j++){

        K_element_type& x_i = K_dmn_t::get_elements()[i];
        K_element_type& x_j = K_dmn_t::get_elements()[j];

        std::vector<scalar_type> delta(DIMENSION, 0);
        for(int li=0; li<DIMENSION; li++)
          delta[li] = (x_j[li]-x_i[li]);

        K_K(i,j) = covariance.execute(delta);//compute_factor(periodic, delta);
      }

      K_K(i,i) += error*error;
    }

    LIN_ALG::matrix<scalar_type, LIN_ALG::CPU> K_K_inv("K_K_inv", std::pair<int,int>(N_c, N_c));

    LIN_ALG::PSEUDO_INVERSE<LIN_ALG::CPU>::execute(K_K, K_K_inv);

    LIN_ALG::matrix<scalar_type, LIN_ALG::CPU> interpolation_matrix_tmp("K_K_inv", std::pair<int,int>(N_r, N_c));

    for(int i=0; i<N_r; i++){
      for(int j=0; j<N_c; j++){

        k_element_type& x_i = k_dmn_t::get_elements()[i];
        K_element_type& x_j = K_dmn_t::get_elements()[j];

        std::vector<scalar_type> delta(DIMENSION, 0);
        for(int li=0; li<DIMENSION; li++)
          delta[li] = (x_j[li]-x_i[li]);

        interpolation_matrix_tmp(i,j) = covariance.execute(delta);
      }

      interpolation_matrix_tmp(i,i) += error*error;
    }

    LIN_ALG::GEMM<LIN_ALG::CPU>::execute('N', 'N', interpolation_matrix_tmp, K_K_inv, interpolation_matrix);
  }

  template<typename scalar_type, typename K_dmn_t, typename k_dmn_t>
  template<typename covariance_type>
  void gaussian_fit<scalar_type, K_dmn_t, k_dmn_t>::initialize_correlation_matrix(covariance_type& covariance, double error)
  {
    int N_c = K_dmn_t::dmn_size();
    int N_r = k_dmn_t::dmn_size();

    correlation_matrix.resize_no_copy(std::pair<int,int>(N_r, N_r));

    for(int i=0; i<N_r; i++){
      for(int j=0; j<N_r; j++){

        k_element_type& x_i = k_dmn_t::get_elements()[i];
        k_element_type& x_j = k_dmn_t::get_elements()[j];

        std::vector<scalar_type> delta(DIMENSION, 0);
        for(int li=0; li<DIMENSION; li++)
          delta[li] = (x_j[li]-x_i[li]);

        correlation_matrix(i,j) = covariance.execute(delta);
      }

      correlation_matrix(i,i) += error*error;
    }

    LIN_ALG::matrix<scalar_type, LIN_ALG::CPU> k_to_K("k_to_K", std::pair<int,int>(N_c, N_r));

    for(int i=0; i<N_c; i++){
      for(int j=0; j<N_r; j++){

        K_element_type& x_i = K_dmn_t::get_elements()[i];
        k_element_type& x_j = k_dmn_t::get_elements()[j];

        std::vector<scalar_type> delta(DIMENSION, 0);
        for(int li=0; li<DIMENSION; li++)
          delta[li] = (x_j[li]-x_i[li]);

        correlation_matrix(i,j) = covariance.execute(delta);
      }

      k_to_K(i,i) += error*error;
    }

    LIN_ALG::GEMM<LIN_ALG::CPU>::execute('N', 'N', scalar_type(-1), interpolation_matrix, k_to_K, scalar_type(1), correlation_matrix);
  }

  /*
  template<typename scalar_type, typename K_dmn_t, typename k_dmn_t>
  template<typename other_scalar_type>
  scalar_type gaussian_fit<scalar_type, K_dmn_t, k_dmn_t>::compute_factor(bool periodic, std::vector<other_scalar_type>& x_i)
  {
    scalar_type factor = 0;

    if(periodic)
      {
        for(int d=0; d<DIMENSION; d++)
          factor = std::pow(std::sin(M_PI*x_i[d]/l[d]), 2);
      }
    else
      {
        for(int d=0; d<DIMENSION; d++)
          factor += std::pow(x_i[d]/l[d], 2);
      }

    return std::exp(-2.*factor);
  }
  */

  /*
  // page 19, eqn 2.31, Rasmussen and Williams
  template<typename scalar_type, typename lhs_dmn_t, typename rhs_dmn_t>
  void gaussian_fit<scalar_type, lhs_dmn_t, rhs_dmn_t>::compute_K(scalar_type s_f, scalar_type l, scalar_type sigma)
  {
  for(int i=0; i<Nc; i++){
  for(int j=0; j<Nc; j++){

  lhs_element_type& x_i = lhs_dmn_t::get_elements()[i];
  lhs_element_type& x_j = lhs_dmn_t::get_elements()[j];

  k(i,j) = (s_f*s_f)*std::exp(-0.5*VECTOR_OPERATIONS::L2_NORM(x_i, x_j)/(l*l));
  }

  k(i,i) += sigma*sigma;
  }

  LIN_ALG::PSEUDO_INVERSE<LIN_ALG::CPU>::execute(k, k_inv);

  for(int i=0; i<Nr; i++){
  for(int j=0; j<Nr; j++){

  rhs_element_type& x_i = rhs_dmn_t::get_elements()[i];
  rhs_element_type& x_j = rhs_dmn_t::get_elements()[j];

  K(i,j) = (s_f*s_f)*std::exp(-0.5*VECTOR_OPERATIONS::L2_NORM(x_i, x_j)/(l*l));
  }
  }

  for(int i=0; i<Nr; i++){
  for(int j=0; j<Nc; j++){

  rhs_element_type& x_i = rhs_dmn_t::get_elements()[i];
  lhs_element_type& x_j = lhs_dmn_t::get_elements()[j];

  K_k(i,j) = (s_f*s_f)*std::exp(-0.5*VECTOR_OPERATIONS::L2_NORM(x_i, x_j)/(l*l));
  }
  }

  for(int i=0; i<Nc; i++){
  for(int j=0; j<Nr; j++){

  lhs_element_type& x_i = lhs_dmn_t::get_elements()[i];
  rhs_element_type& x_j = rhs_dmn_t::get_elements()[j];

  k_K(i,j) = (s_f*s_f)*std::exp(-0.5*VECTOR_OPERATIONS::L2_NORM(x_i, x_j)/(l*l));
  }
  }

  LIN_ALG::GEMM<LIN_ALG::CPU>::execute('N', 'N', K_k, k_inv, T);

  LIN_ALG::GEMM<LIN_ALG::CPU>::execute('N', 'N', scalar_type(-1), T, k_K, scalar_type(1), K);
  }

  template<typename scalar_type, typename lhs_dmn_t, typename rhs_dmn_t>
  void gaussian_fit<scalar_type, lhs_dmn_t, rhs_dmn_t>::compute_K_periodic(scalar_type s_f, scalar_type l, scalar_type sigma)
  {
  LIN_ALG::matrix<scalar_type, LIN_ALG::CPU> A("A", DIMENSION);

  for(int i=0; i<DIMENSION; i++)
  for(int j=0; j<DIMENSION; j++)
  A(i,j) = lhs_dmn_t::parameter_type::get_super_basis()[i+j*DIMENSION];

  LIN_ALG::GEINV<LIN_ALG::CPU>::execute(A);

  for(int i=0; i<Nc; i++){
  for(int j=0; j<Nc; j++){

  lhs_element_type& x_i = lhs_dmn_t::get_elements()[i];
  lhs_element_type& x_j = lhs_dmn_t::get_elements()[j];

  scalar_type factor = compute_factor(x_i, x_j, A);

  k(i,j) = (s_f*s_f)*std::exp(-2.*factor/(l*l));
  }

  k(i,i) += sigma*sigma;
  }

  LIN_ALG::PSEUDO_INVERSE<LIN_ALG::CPU>::execute(k, k_inv);

  for(int i=0; i<Nr; i++){
  for(int j=0; j<Nr; j++){

  rhs_element_type& x_i = rhs_dmn_t::get_elements()[i];
  rhs_element_type& x_j = rhs_dmn_t::get_elements()[j];

  double factor = compute_factor(x_i, x_j, A);

  K(i,j) = (s_f*s_f)*std::exp(-2.*factor/(l*l));
  }
  }

  for(int i=0; i<Nr; i++){
  for(int j=0; j<Nc; j++){

  rhs_element_type& x_i = rhs_dmn_t::get_elements()[i];
  lhs_element_type& x_j = lhs_dmn_t::get_elements()[j];

  double factor = compute_factor(x_i, x_j, A);

  K_k(i,j) = (s_f*s_f)*std::exp(-2.*factor/(l*l));
  }
  }

  for(int i=0; i<Nc; i++){
  for(int j=0; j<Nr; j++){

  lhs_element_type& x_i = lhs_dmn_t::get_elements()[i];
  rhs_element_type& x_j = rhs_dmn_t::get_elements()[j];

  double factor = compute_factor(x_i, x_j, A);

  k_K(i,j) = (s_f*s_f)*std::exp(-2.*factor/(l*l));
  }
  }

  LIN_ALG::GEMM<LIN_ALG::CPU>::execute('N', 'N', K_k, k_inv, T);

  LIN_ALG::GEMM<LIN_ALG::CPU>::execute('N', 'N', scalar_type(-1), T, k_K, scalar_type(1), K);
  }

  template<typename scalar_type, typename lhs_dmn_t, typename rhs_dmn_t>
  scalar_type gaussian_fit<scalar_type, lhs_dmn_t, rhs_dmn_t>::compute_factor(lhs_element_type& x_i,
  lhs_element_type& x_j,
  LIN_ALG::matrix<scalar_type, LIN_ALG::CPU>& A)
  {
  scalar_type delta_0[DIMENSION];
  scalar_type delta_1[DIMENSION];

  for(int i=0; i<DIMENSION; i++)
  delta_0[i] = x_j[i]-x_i[i];

  for(int i=0; i<DIMENSION; i++)
  delta_1[i] = 0.;

  for(int j=0; j<DIMENSION; j++)
  for(int i=0; i<DIMENSION; i++)
  delta_1[i] += A(i,j)*delta_0[j];

  scalar_type factor = 0.;
  for(int i=0; i<DIMENSION; i++)
  factor += std::pow(std::sin(M_PI*delta_1[i]), 2);

  return factor;
  }
  */

}

#endif
