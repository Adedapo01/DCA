//-*-C++-*-

#ifndef COVARIANCE_FUNCTION_PERIODIC_SQUARED_EXPONENTIAL_H
#define COVARIANCE_FUNCTION_PERIODIC_SQUARED_EXPONENTIAL_H

namespace MATH_LIBRARY
{
  /*!
   *
   *    page 19, eqn 2.31, Rasmussen and Williams
   */
  template<typename k_dmn_t>
  class covariance_function<PERIODIC_SQUARED_EXPONENTIAL, k_dmn_t>
  {
    const static int DIMENSION = k_dmn_t::parameter_type::DIMENSION;

  public:

    covariance_function();
    ~covariance_function();

    double execute(std::vector<double>& x_i);

    void plot();

  public:

    double sigma_f;

    LIN_ALG::matrix<double, LIN_ALG::CPU> A;
  };

  template<typename k_dmn_t>
  covariance_function<PERIODIC_SQUARED_EXPONENTIAL, k_dmn_t>::covariance_function():
    sigma_f(1.),

    A("A", std::pair<int,int>(DIMENSION,DIMENSION))
  {
    LIN_ALG::matrix<double, LIN_ALG::CPU> T("T", std::pair<int,int>(DIMENSION,DIMENSION));

    for(int li=0; li<DIMENSION; li++)
      for(int lj=0; lj<DIMENSION; lj++)
        for(int lk=0; lk<DIMENSION; lk++)
          T(li,lj) += k_dmn_t::parameter_type::get_inverse_super_basis()[li+lk*DIMENSION]*
            k_dmn_t::parameter_type::get_basis()[lk+lj*DIMENSION];

    for(int li=0; li<DIMENSION; li++)
      for(int lj=0; lj<DIMENSION; lj++)
        for(int lk=0; lk<DIMENSION; lk++)
          A(li,lj) += T(li,lk)*T(lj,lk);
  }

  template<typename k_dmn_t>
  covariance_function<PERIODIC_SQUARED_EXPONENTIAL, k_dmn_t>::~covariance_function()
  {}

  template<typename k_dmn_t>
  double covariance_function<PERIODIC_SQUARED_EXPONENTIAL, k_dmn_t>::execute(std::vector<double>& x_i)
  {
    std::vector<double> y_i(DIMENSION, 0.);

    for(int li=0; li<DIMENSION; li++)
      for(int lj=0; lj<DIMENSION; lj++)
        y_i[li] += k_dmn_t::parameter_type::get_inverse_super_basis()[li+lj*DIMENSION]*x_i[lj];

    for(int li=0; li<DIMENSION; li++)
      y_i[li] = std::sin(M_PI*y_i[li]);

    double result=0;

    for(int li=0; li<DIMENSION; li++)
      for(int lj=0; lj<DIMENSION; lj++)
        result += y_i[li]*A(li,lj)*y_i[lj];

    return sigma_f*std::exp(-result);
  }

  template<typename k_dmn_t>
  void covariance_function<PERIODIC_SQUARED_EXPONENTIAL, k_dmn_t>::plot()
  {
    std::vector<double> x(0);
    std::vector<double> y(0);
    std::vector<double> z(0);

    for(int l=0; l<k_dmn_t::dmn_size(); l++){
      x.push_back(        k_dmn_t::get_elements()[l][0]);
      y.push_back(        k_dmn_t::get_elements()[l][1]);
      z.push_back(execute(k_dmn_t::get_elements()[l])  );
    }

    SHOW::heatmap(x,y,z);
  }

}

#endif
