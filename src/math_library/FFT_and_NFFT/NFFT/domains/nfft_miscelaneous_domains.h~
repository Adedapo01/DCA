//-*-C++-*-

#ifndef MATH_ALGORITHMS_NFFT_MISCELANIOUS_DOMAINS_H
#define MATH_ALGORITHMS_NFFT_MISCELANIOUS_DOMAINS_H

namespace MATH_ALGORITHMS
{
  namespace NFFT
  {
    struct nfft_coefficients_domain
    {
      const static int DIMENSION = 1;

      typedef int scalar_type;
      typedef int element_type;

    public:

      static int& get_size()
      {
        static int size=4;
        return size;
      }

      static std::string get_name()
      {
        return "nfft_coefficients_domain";
      }

      static std::vector<element_type>& get_elements()
      {
        static std::vector<element_type> elements(0);
        return elements;
      }
    };


    struct nfft_oversampling_domain
    {
      const static int DIMENSION = 1;

      typedef int scalar_type;
      typedef int element_type;

    public:

      static int& get_size()
      {
        static int size=-1;
        return size;
      }

      static std::string get_name()
      {
        return "nfft_oversampling_domain";
      }

      static std::vector<element_type>& get_elements()
      {
        static std::vector<element_type> elements(0);
        return elements;
      }

      static void initialize(dnfft_type& dnfft_obj)
      {
        get_size() = dnfft_obj.get_oversampling_factor();
      }
    };

    struct nfft_window_sampling_domain
    {
      const static int DIMENSION = 1;

      typedef int scalar_type;
      typedef int element_type;

    public:

      static int& get_size()
      {
        static int size=-1;
        return size;
      }

      static std::string get_name()
      {
        return "nfft_window_sampling_domain";
      }

      static std::vector<element_type>& get_elements()
      {
        static std::vector<element_type> elements(0);
        return elements;
      }

      static void initialize(dnfft_type& dnfft_obj)
      {
        get_size() = dnfft_obj.get_window_sampling_factor();
      }
    };

  }

}

#endif
