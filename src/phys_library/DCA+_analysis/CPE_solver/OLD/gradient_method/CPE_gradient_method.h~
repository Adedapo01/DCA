//-*-C++-*-

/*
 *      Author: peterstaar
 */

#ifndef CONTINUOUS_POLE_EXPANSION_H
#define CONTINUOUS_POLE_EXPANSION_H

template<class parameters_type, class concurrency_type, class basis_function_t>
class continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>
{
#include "type_definitions.h"  

public:

  typedef typename parameters_type::profiler_type profiler_t;

public:
  
  continuous_pole_expansion(parameters_type&  parameters,
			    concurrency_type& concurrency,
			    bool              fixed_zero_moment=false,
			    double            zero_moment=0,
			    bool              fixed_first_moment=false,
			    double            first_moment=1);

  ~continuous_pole_expansion();

  template<typename target_dmn_t>
  void execute(function<std::complex<double>, dmn_4<nu, nu, k_DCA, w> >&            f_source, 
	       function<std::complex<double>, dmn_4<nu, nu, k_DCA, target_dmn_t> >& f_target,
	       bool                                                                 use_previous_result=false);

  template<typename stream_type>
  void domains_to_JSON(stream_type& ss);

  template<typename stream_type>
  void to_JSON(stream_type& ss);

private:

  void initialize();

  bool spline_input_values_to_wn(std::complex<double>* input_values);

  void perform_continuous_pole_expansion();

  void f_wn_distribute(int dmn_number, int* coordinate);

  void compute_gradient_alphas(bool normalize=true);
  void compute_gradient_Sigma_0(bool normalize=true);

  void find_new_Sigma_0(double LAMBDA_MAX=1.);
  int  find_new_alpha(double LAMBDA_MAX=1.);

  void project_from_real_axis_to_imaginary_axis(double* real_values, double* imag_values, double* matrix);
  void project_from_imaginary_axis_to_real_axis(double* imag_values, double* real_values, double* matrix);

  template<typename target_dmn_t>
  void spline_alpha_to_output_values(target_dmn_t& target_dmn, std::complex<double>* output_values);

  void spline_alpha_to_output_values_w_IMAG(std::complex<double>* output_values);
  void spline_alpha_to_output_values_w_REAL(std::complex<double>* output_values);

private:

  typedef dmn_0<basis_function_t>        alpha_dmn_t;
  typedef dmn_4<nu,nu,k_DCA,alpha_dmn_t> nu_nu_k_DCA_alpha_dmn;

  parameters_type&  parameters;
  concurrency_type& concurrency;

  bool static_zero_moment;
  bool project_to_unit_plane;

  double Sigma_0;

  function<std::complex<double>, nu_nu_k_DCA>        Sigma_0_moment;
  
  function<double              , nu_nu_k_DCA_alpha_dmn> alpha;

  function<std::complex<double>, nu_nu_k_DCA_w_IMAG> f_approx;
  function<std::complex<double>, nu_nu_k_DCA_w_IMAG> f_measured;

  double grad_Sigma_0;

  function<double, alpha_dmn_t> alpha_ptr;

  function<double, w_IMAG> f_wn_re_ptr;
  function<double, w_IMAG> f_wn_im_ptr;
  function<double, w_IMAG> F_wn_re_ptr;
  function<double, w_IMAG> F_wn_im_ptr;

  function<double, alpha_dmn_t> gradient;
  function<double, alpha_dmn_t> gradient_1;
  function<double, alpha_dmn_t> gradient_2;

  function<double, alpha_dmn_t> a_new    ;
  function<double, alpha_dmn_t> a_new_cpy;

  double* A1;
  double* A2;

  int lower_bound, upper_bound, bounds_difference;
};

template<class parameters_type, class concurrency_type, class basis_function_t>
continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::continuous_pole_expansion(parameters_type&  parameters_ref,
															   concurrency_type& concurrency_ref,
															   bool              fixed_zeroth_moment,
															   double            zeroth_moment_val,
															   bool              fixed_first_moment,
															   double            first_moment_val):
  parameters(parameters_ref),
  concurrency(concurrency_ref),

  static_zero_moment(fixed_zeroth_moment),
  project_to_unit_plane(fixed_first_moment),

  Sigma_0(zeroth_moment_val),

  alpha("alpha"),
  f_approx("f-approx"),

  f_measured("f-measured")
  {
    basis_function_t::initialize(parameters);

    alpha.reset();

    alpha_ptr.reset();

    gradient.reset();
    gradient_1.reset();
    gradient_2.reset();

    a_new.reset();
    a_new_cpy.reset();

    initialize();
  }

template<class parameters_type, class concurrency_type, class basis_function_t>
continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::~continuous_pole_expansion()
{
  delete [] A1;
  delete [] A2;
}

template<class parameters_type, class concurrency_type, class basis_function_t>
template<typename stream_type>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::to_JSON(stream_type& ss)
{
  alpha.to_JSON(ss);
  ss << ",";

  f_approx.to_JSON(ss);
  ss << ",";

  f_measured.to_JSON(ss);
}

template<class parameters_type, class concurrency_type, class basis_function_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::initialize()
{
  { // initialize bounds for matrices A_1 and A_2
    //w_REAL              w_REAL_dmn;
//     alpha_dmn_t         alpha_dmn;
//     std::pair<int, int> bounds = concurrency.get_bounds(alpha_dmn); 

//     lower_bound = bounds.first;
//     upper_bound = bounds.second;

//     bounds_difference = bounds.second-bounds.first;

    lower_bound = 0;
    upper_bound = alpha_dmn_t::dmn_size();

    bounds_difference = upper_bound-lower_bound;

    assert(bounds_difference>=0);
  }
  
  { // transfer-matrices
    A1 = new double[bounds_difference*w_IMAG::dmn_size()];
    A2 = new double[bounds_difference*w_IMAG::dmn_size()];

    for(int n=0; n<w_IMAG::dmn_size(); n++)
      {  
	std::complex<double> z(0., w_IMAG::get_elements()[n]);

	for(int xi=0; xi<bounds_difference; xi++) 
	  {
	    int I = xi+lower_bound;
	    
	    A1[xi + bounds_difference*n] = real(basis_function_t::phi(I, z));
	    A2[xi + bounds_difference*n] = imag(basis_function_t::phi(I, z));
	  }
      }
  }
}

template<class parameters_type, class concurrency_type, class basis_function_t>
template<typename target_dmn_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::execute(function<std::complex<double>,       nu_nu_k_DCA_w             >& f_source, 
													      function<std::complex<double>, dmn_4<nu,nu,k_DCA,target_dmn_t> >& f_target,
													      bool                                                              use_previous_result)
{
  const static int dmn_number = 5;

  nu_nu_k_DCA  parallelized_dmn;
  target_dmn_t target_dmn;

  int Nb_sbdms    = f_source.signature();
  
  int* coordinate = new int[Nb_sbdms];
  memset(coordinate,0,sizeof(int)*Nb_sbdms);
  
  std::complex<double>* input_values  = new std::complex<double>[f_source[dmn_number] ];
  std::complex<double>* output_values = new std::complex<double>[f_target[dmn_number] ];

  thread_manager_sum<concurrency_type> sum_manager(concurrency);
  
  do
    {
      std::pair<int, int> dmn_bounds = sum_manager.get_bounds(parallelized_dmn);

      for(int l=dmn_bounds.first; l<dmn_bounds.second; l++)
	{
	  int linind = l;
	  for(int j=Nb_sbdms-1; j>-1; j--)
	    {
	      if(j != dmn_number)
		{
		  coordinate[j] = linind % f_source[j];
		  linind = (linind-coordinate[j])/f_source[j];
		}
	    }
	
	  f_source.slice(dmn_number, coordinate, input_values);

	  bool to_be_done = spline_input_values_to_wn(input_values);

	  if(to_be_done && coor[0]==coor[2] && coor[1]==coor[3])
	    {
	      f_measured.distribute(dmn_number, coordinate, &input_values[w::dmn_size()/2]);

	      perform_continuous_pole_expansion();

	      f_wn_distribute(dmn_number, coordinate);

	      alpha.distribute(dmn_number, coordinate, &alpha_ptr(0));

	      spline_alpha_to_output_values(target_dmn, output_values); 
	    
	      f_target.distribute(dmn_number, coordinate, output_values);
	    }
	}
    }
  while(!sum_manager.sum_and_check(f_target));

  concurrency.sum(alpha);
  concurrency.sum(f_approx);
  concurrency.sum(f_measured);

  delete [] coordinate;
  delete [] input_values;
  delete [] output_values;
}

template<class parameters_type, class concurrency_type, class basis_function_t>
bool continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::spline_input_values_to_wn(std::complex<double>* input_values)
{
  assert(w_IMAG::dmn_size() == w::dmn_size()/2);

  bool to_be_done = false;
  for(int n=0; n<w_IMAG::dmn_size(); n++){
    F_wn_re_ptr(n) = real(input_values[w::dmn_size()/2+n]);	
    F_wn_im_ptr(n) = imag(input_values[w::dmn_size()/2+n]);
    
    if(abs(input_values[n]) > 1.e-6)
      to_be_done = true;
  }

  return to_be_done;
}

template<class parameters_type, class concurrency_type, class basis_function_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::f_wn_distribute(int dmn_number, 
														      int* coordinate)
{
  assert(w_IMAG::dmn_size() == w::dmn_size()/2);

  std::complex<double>* f_wn_ptr = new std::complex<double>[w_IMAG::dmn_size()];

  for(int n=0; n<w_IMAG::dmn_size(); n++){
    real(f_wn_ptr[n]) = f_wn_re_ptr(n);
    imag(f_wn_ptr[n]) = f_wn_im_ptr(n);
  }

  f_approx.distribute(dmn_number, coordinate, f_wn_ptr);

  delete [] f_wn_ptr;
}

template<class parameters_type, class concurrency_type, class basis_function_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::perform_continuous_pole_expansion()
{
  Sigma_0      = 0;
  grad_Sigma_0 = 0;

  for(int n=0; n<alpha_dmn_t::dmn_size(); n++)
    alpha_ptr(n) = 0;
      
  int MAX_ITERATIONS = parameters.get_max_iterations();
  int CPE_iteration  = 0;

  while(MAX_ITERATIONS>CPE_iteration)
    {
      if(!static_zero_moment)
	find_new_Sigma_0();

      int index = find_new_alpha();
            
      if(index == 1)
	break;

      CPE_iteration++;
    }
}

template<class parameters_type, class concurrency_type, class basis_function_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::compute_gradient_Sigma_0(bool normalize)
{
  project_from_real_axis_to_imaginary_axis(&alpha_ptr(0), &f_wn_re_ptr(0), A1);
//   concurrency.sum(f_wn_re_ptr);

  for(int n=0; n<w_IMAG::dmn_size(); n++)
    f_wn_re_ptr(n) = F_wn_re_ptr(n)-(f_wn_re_ptr(n)+Sigma_0);
  
  grad_Sigma_0=0.;
  for(int n=0; n<w_IMAG::dmn_size(); n++)
    grad_Sigma_0 += -2.*f_wn_re_ptr(n);
}

template<class parameters_type, class concurrency_type, class basis_function_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::find_new_Sigma_0(double LAMBDA_MAX)
{
  for(int i=0; i<10; i++)
    {
      compute_gradient_Sigma_0();
      Sigma_0 = Sigma_0 - grad_Sigma_0/double(2*w_IMAG::dmn_size());
    }
}

template<class parameters_type, class concurrency_type, class basis_function_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::compute_gradient_alphas(bool normalize)
{
//     grad_F = -2*A1*(real(spoints) - transpose(A1)*a) ...
//               - 2*A2*(imag(spoints) - transpose(A2)*a);

  {// compute the gradient
    {// -2*A1*(real(spoints) - transpose(A1)*a)
      project_from_real_axis_to_imaginary_axis(&alpha_ptr(0), &f_wn_re_ptr(0), A1);
//       concurrency.sum(f_wn_re_ptr);
	
      for(int n=0; n<w_IMAG::dmn_size(); n++)
	f_wn_re_ptr(n) = F_wn_re_ptr(n)-(f_wn_re_ptr(n)+Sigma_0);

      project_from_imaginary_axis_to_real_axis(&f_wn_re_ptr(0), &gradient_1(0), A1);
//       concurrency.sum(gradient_1);
	
      for(int n=0; n<alpha_dmn_t::dmn_size(); n++)
	gradient_1(n) = (-2.)*gradient_1(n);
    }

    {// -2*A2*(imag(spoints) - transpose(A2)*a)
      project_from_real_axis_to_imaginary_axis(&alpha_ptr(0), &f_wn_im_ptr(0), A2);
//       concurrency.sum(f_wn_im_ptr);
	
      for(int n=0; n<w_IMAG::dmn_size(); n++) 
	f_wn_im_ptr(n) = F_wn_im_ptr(n)-f_wn_im_ptr(n);
	
      project_from_imaginary_axis_to_real_axis(&f_wn_im_ptr(0), &gradient_2(0), A2);
//       concurrency.sum(gradient_2);
	
      for(int n=0; n<alpha_dmn_t::dmn_size(); n++)
	gradient_2(n) = (-2.)*gradient_2(n);
    }
  }

  if(normalize)
    { // normalize
      double norm_gradient = 0;
      for(int n=0; n<alpha_dmn_t::dmn_size(); n++)
	norm_gradient += (gradient_1(n) + gradient_2(n))*(gradient_1(n) + gradient_2(n));
      
      for(int n=0; n<alpha_dmn_t::dmn_size(); n++)
	gradient(n) = -(gradient_1(n) + gradient_2(n))/sqrt(norm_gradient);
    }
}

template<class parameters_type, class concurrency_type, class basis_function_t>
int continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::find_new_alpha(double LAMBDA_MAX)
{
  compute_gradient_alphas();

  double L2_norm   = 1;
  double L2_norm_0 = 0;

  memcpy(&a_new_cpy(0), &alpha_ptr(0), sizeof(double)*alpha_dmn_t::dmn_size());

  double lambda       = 0;
  double delta_lambda = LAMBDA_MAX/100.;

  int index = 0;

  while(true)
    {
      for(int n=0; n<alpha_dmn_t::dmn_size(); n++){
	double value = alpha_ptr(n) + lambda*gradient(n);
	value < 0 ? a_new(n) = 0 : a_new(n) = value;
      }

      project_from_real_axis_to_imaginary_axis(&a_new(0), &f_wn_re_ptr(0), A1);
      project_from_real_axis_to_imaginary_axis(&a_new(0), &f_wn_im_ptr(0), A2);

//       concurrency.sum(f_wn_re_ptr);
//       concurrency.sum(f_wn_im_ptr);
	  
      for(int n=0; n<w_IMAG::dmn_size(); n++)
	f_wn_re_ptr(n) += Sigma_0;

      L2_norm = 0;
      for(int n=0; n<w_IMAG::dmn_size(); n++)
	L2_norm += square(f_wn_re_ptr(n)-F_wn_re_ptr(n)) + square(f_wn_im_ptr(n)-F_wn_im_ptr(n));

      if(index == 0 || (L2_norm_0 - L2_norm)/L2_norm > 1.e-4/*L2_norm < L2_norm_0*/){
	L2_norm_0 = L2_norm;
	memcpy(&a_new_cpy(0), &a_new(0), sizeof(double)*alpha_dmn_t::dmn_size());
      }
      else
	break;

      lambda += delta_lambda;

      index++;

      if(index>20)
	delta_lambda = LAMBDA_MAX/10.;

      if(index>100)
	delta_lambda = LAMBDA_MAX/1.;
    }

  memcpy(&alpha_ptr(0), &a_new_cpy(0), sizeof(double)*alpha_dmn_t::dmn_size());

  return index;
}
      
template<class parameters_type, class concurrency_type, class basis_function_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::project_from_real_axis_to_imaginary_axis(double* real_values, double* imag_values, double* matrix)
{
  gemv_plan<double> gemv_obj(bounds_difference, w_IMAG::dmn_size()); 

  for(int l=0; l<w_IMAG::dmn_size(); l++)
    imag_values[l]=0.;

  gemv_obj.TRANS         = 'T';
	  
  gemv_obj.alpha         =  1;
  gemv_obj.beta          =  0.;
  
  gemv_obj.matrix        = matrix;
  gemv_obj.vector_source = &real_values[lower_bound];
  gemv_obj.vector_target = imag_values;
  
  gemv_obj.execute_plan();
}

template<class parameters_type, class concurrency_type, class basis_function_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::project_from_imaginary_axis_to_real_axis(double* imag_values, double* real_values, double* matrix)
{
  gemv_plan<double> gemv_obj(bounds_difference, w_IMAG::dmn_size()); 

  for(int l=0; l<alpha_dmn_t::dmn_size(); l++)
    real_values[l]=0.;

  gemv_obj.TRANS         = 'N';
	  
  gemv_obj.alpha         =  1;
  gemv_obj.beta          =  0.;
  
  gemv_obj.matrix        = matrix;
  gemv_obj.vector_source = imag_values;
  gemv_obj.vector_target = &real_values[lower_bound];
  
  gemv_obj.execute_plan();
}

template<class parameters_type, class concurrency_type, class basis_function_t>
template<typename target_dmn_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::spline_alpha_to_output_values(target_dmn_t& target_dmn, std::complex<double>* output_values)
{
//   print_type< target_dmn_t>::print();

  if(IS_EQUAL_TYPE<target_dmn_t, w>::check){
    spline_alpha_to_output_values_w_IMAG(output_values);
    return;
  }

  if(IS_EQUAL_TYPE<target_dmn_t, w_REAL>::check){
    spline_alpha_to_output_values_w_REAL(output_values);
    return;
  }

  throw std::logic_error(__FUNCTION__);
}

template<class parameters_type, class concurrency_type, class basis_function_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::spline_alpha_to_output_values_w_IMAG(std::complex<double>* output_values)
{
  double sum=0;

  for(int n=0; n<alpha_dmn_t::dmn_size(); n++)
    sum += alpha_ptr(n)*basis_function_t::volume(n);

  int left_index=0;
  int right_index=alpha_dmn_t::dmn_size()-1;
  double num=0;

  while(alpha_ptr(left_index)<1.e-6){
    left_index++;
    num++;
  }

  while(alpha_ptr(right_index)<1.e-6){
    right_index--;
    num++;
  }

  for(int n=0; n<left_index; n++)
    alpha_ptr(n) += (1-sum)/basis_function_t::volume(n)/num;//(left_index+alpha_dmn_t::dmn_size()-right_index);

  for(int n=alpha_dmn_t::dmn_size()-1; n>right_index; n--)
    alpha_ptr(n) += (1-sum)/basis_function_t::volume(n)/num;//(left_index+alpha_dmn_t::dmn_size()-right_index);

  sum=0;

  for(int n=0; n<alpha_dmn_t::dmn_size(); n++)
    sum += alpha_ptr(n)*basis_function_t::volume(n);

  concurrency << "\n\t sum : ";
  concurrency << sum;
  concurrency << "\t  m_0 : ";
  concurrency << Sigma_0;
  concurrency << "\n";

  for(int m=0; m<w::dmn_size(); m++)
    {
      output_values[m] = 0;
      
      std::complex<double> z(0., w::get_elements()[m]);

      for(int n=0; n<alpha_dmn_t::dmn_size(); n++)
	output_values[m] += alpha_ptr(n)*basis_function_t::phi(n, z);//sum;
    }
} 

template<class parameters_type, class concurrency_type, class basis_function_t>
void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::spline_alpha_to_output_values_w_REAL(std::complex<double>* output_values)
{
  for(int m=0; m<w_REAL::dmn_size(); m++)
    {
      output_values[m] = Sigma_0;
      
      std::complex<double> z(w_REAL::get_elements()[m], 1.e-12);

//       for(int xi=0; xi<w_REAL::dmn_size(); xi++){
// 	std::complex<double> x0(w_REAL::get_elements()[xi]-deltalpha, 0.);
// 	std::complex<double> x1(w_REAL::get_elements()[xi]        , 0.);
// 	std::complex<double> x2(w_REAL::get_elements()[xi]+deltalpha, 0.);

      for(int n=0; n<alpha_dmn_t::dmn_size(); n++)
	output_values[m] += alpha_ptr(n)*basis_function_t::phi(n, z);//((-x0 + x1 + (x0 - z)*(std::log(x0 - z) - std::log(x1 - z)))/(x0 - x1) + (x1 - x2 - (x2 - z)*(std::log(-x1 + z) - std::log(-x2 + z)))/(x1 - x2));
//       }
    }
}

#endif


































































// template<class parameters_type, class concurrency_type, class basis_function_t>
// void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::execute(function<std::complex<double>, nu_nu_k_DCA_w>& f_source, 
// 													      function<std::complex<double>, nu_nu_k_DCA_w>& f_target,
// 													      bool                                           use_previous_result)
// {
//   concurrency << "\n\n\t --> condition_Greens_function \n\n";

//   static_zero_moment    = true;
//   project_to_unit_plane = true;

//   Sigma_0 = 0.;

//   perform_continuous_pole_expansion(f_source, f_target);

//   static_zero_moment    = false;
//   project_to_unit_plane = false;
// }

// template<class parameters_type, class concurrency_type, class basis_function_t>
// void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::execute(function<std::complex<double>, nu_nu_k_DCA_w>& f_source, 
// 													      function<std::complex<double>, nu_nu_k_DCA_w>& f_target,
// 													      bool                                           use_previous_result)
// {
//   const static int dmn_number = 5;

//   concurrency << "\n\n\t --> condition_Greens_function \n\n";

//   static_zero_moment    = true;
//   project_to_unit_plane = true;

//   Sigma_0 = 0.;

//   w   target_dmn;

//   int Nb_sbdms    = f_source.signature();
//   int Nb_elements = f_source.size();
  
//   int* coordinate = new int[Nb_sbdms];
//   memset(coordinate,0,sizeof(int)*Nb_sbdms);
  
//   std::complex<double>* input_values    = new std::complex<double>[f_source[dmn_number] ];
//   std::complex<double>* output_values   = new std::complex<double>[f_target[dmn_number] ];

//   {
//     int Nb_Pade = Nb_elements/f_source[dmn_number];
    
//     for(int l=0; l<Nb_Pade; l++)
//       {
// 	int linind = l;
// 	for(int j=Nb_sbdms-1; j>-1; j--)
// 	  {
// 	    if(j != dmn_number)
// 	      {
// 		coordinate[j] = linind % f_source[j];
// 		linind = (linind-coordinate[j])/f_source[j];
// 	      }
// 	  }
	
// 	f_source.slice(dmn_number, coordinate, input_values);

// 	bool to_be_done = spline_input_values_to_wn(input_values);

// 	if(to_be_done)
// 	  {
// 	    S_wn.distribute(dmn_number, coordinate, &input_values[w::dmn_size()/2]);

// 	    perform_continuous_pole_expansion();

// 	    a_wn_distribute(dmn_number, coordinate);

// 	    a_x.distribute(dmn_number, coordinate, &a_x_ptr(0));

//  	    spline_a_x_to_output_values(target_dmn, output_values); 
	    
//  	    f_target.distribute(dmn_number, coordinate, output_values);
// 	  }
//       }
//   }

//   delete [] coordinate;
//   delete [] input_values;
//   delete [] output_values;

//   static_zero_moment    = false;
//   project_to_unit_plane = false;
// }

// template<class parameters_type, class concurrency_type, class basis_function_t>
// void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::condition_Greens_function(function<std::complex<double>, nu_nu_k_DCA_w>& f_source, 
// 																function<std::complex<double>, nu_nu_k_DCA_w>& f_target)
// {
//   concurrency << "\n\n\t --> condition_Greens_function \n\n";

//   static_zero_moment    = true;
//   project_to_unit_plane = true;

//   Sigma_0 = 0.;

//   perform_continuous_pole_expansion(f_source, f_target);

//   static_zero_moment    = false;
//   project_to_unit_plane = false;
// }

// template<class parameters_type, class concurrency_type, class basis_function_t>
// void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::perform_continuous_pole_expansion(function<std::complex<double>, nu_nu_k_DCA_w>& f_source, 
// 																	function<std::complex<double>, nu_nu_k_DCA_w>& f_target)
// {
//   const static int dmn_number = 5;

//   w   target_dmn;

//   int Nb_sbdms    = f_source.signature();
//   int Nb_elements = f_source.size();
  
//   int* coordinate = new int[Nb_sbdms];
//   memset(coordinate,0,sizeof(int)*Nb_sbdms);
  
//   std::complex<double>* input_values    = new std::complex<double>[f_source[dmn_number] ];
//   std::complex<double>* output_values   = new std::complex<double>[f_target[dmn_number] ];

//   {
//     int Nb_Pade = Nb_elements/f_source[dmn_number];
    
//     for(int l=0; l<Nb_Pade; l++)
//       {
// 	int linind = l;
// 	for(int j=Nb_sbdms-1; j>-1; j--)
// 	  {
// 	    if(j != dmn_number)
// 	      {
// 		coordinate[j] = linind % f_source[j];
// 		linind = (linind-coordinate[j])/f_source[j];
// 	      }
// 	  }
	
// 	f_source.slice(dmn_number, coordinate, input_values);

// 	bool to_be_done = spline_input_values_to_wn(input_values);

// 	if(to_be_done)
// 	  {
// 	    S_wn.distribute(dmn_number, coordinate, &input_values[w::dmn_size()/2]);

// 	    perform_continuous_pole_expansion();

// 	    a_wn_distribute(dmn_number, coordinate);

// 	    a_x.distribute(dmn_number, coordinate, &a_x_ptr(0));

//  	    spline_a_x_to_output_values(target_dmn, output_values); 
	    
//  	    f_target.distribute(dmn_number, coordinate, output_values);
// 	  }
//       }
//   }

//   delete [] coordinate;
//   delete [] input_values;
//   delete [] output_values;
// }




// template<class parameters_type, class concurrency_type, class basis_function_t>
// template<typename MOMS_t>
// void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::compute_spectral_function(MOMS_t& MOMS)
// {
//   concurrency << "\n\n\t start perform continuous-pole-expansion G \n\n";

//   perform_continuous_pole_expansion(MOMS.Sigma, Sigma);

//   concurrency << "\n\n\t start coarsegraining G0 \n\n";

//   function<std::complex<double>, nu_nu_k_DCA_w_REAL> Sigma_zero;
//   coarsegrain_obj.compute_G_from_H_and_Sigma(MOMS.H_LDA, Sigma_zero, G0_k_w);

//   concurrency << "\n\n\t start coarsegraining G \n\n";
  
//   coarsegrain_obj.compute_G_from_H_and_Sigma(MOMS.H_LDA, Sigma, G_k_w);

//   concurrency << "\n\n\t compute spectra \n\n";

//   for(int b=0; b<b::dmn_size(); b++){
//     for(int s=0; s<s::dmn_size(); s++){
	  
//       for(int w_ind=0; w_ind<w_REAL::dmn_size(); w_ind++){
	
// 	for(int k_ind=0; k_ind<k_DCA::dmn_size(); k_ind++){
// 	  A_nu_w (b,s,w_ind) += -1./M_PI*imag(G_k_w (b,s,b,s,k_ind,w_ind));
// 	  A0_nu_w(b,s,w_ind) += -1./M_PI*imag(G0_k_w(b,s,b,s,k_ind,w_ind));

// 	  A_w (w_ind) += -1./M_PI*imag(G_k_w (b,s,b,s,k_ind,w_ind));
// 	  A0_w(w_ind) += -1./M_PI*imag(G0_k_w(b,s,b,s,k_ind,w_ind));
// 	}
//       }
//     }
//   }

//   A_nu_w  /= (double(k_DCA::dmn_size()));
//   A0_nu_w /= (double(k_DCA::dmn_size()));

//   A_w  /= (double(k_DCA::dmn_size())*b::dmn_size()*s::dmn_size());
//   A0_w /= (double(k_DCA::dmn_size())*b::dmn_size()*s::dmn_size());
// }

// template<class parameters_type, class concurrency_type, class basis_function_t>
// void continuous_pole_expansion<parameters_type, concurrency_type, basis_function_t, GRADIENT_METHOD>::perform_continuous_pole_expansion(function<std::complex<double>, nu_nu_k_DCA_w     >& f_source, 
// 																	function<std::complex<double>, nu_nu_k_DCA_w_REAL>& f_target)
// {
//   const static int dmn_number = 5;

//   int Nb_sbdms    = f_source.signature();
//   int Nb_elements = f_source.size();
  
//   int* coordinate = new int[Nb_sbdms];
//   memset(coordinate,0,sizeof(int)*Nb_sbdms);
  
//   std::complex<double>* input_values    = new std::complex<double>[f_source[dmn_number] ];
//   std::complex<double>* output_values   = new std::complex<double>[f_target[dmn_number] ];

//   {
//     int Nb_Pade = Nb_elements/f_source[dmn_number];
    
//     for(int l=0; l<Nb_Pade; l++)
//       {
// 	concurrency << "\n\t\t ";
// 	concurrency << int(double(l)/double(Nb_Pade)*100);
// 	concurrency << " % completed";

// 	int linind = l;
// 	for(int j=Nb_sbdms-1; j>-1; j--)
// 	  {
// 	    if(j != dmn_number)
// 	      {
// 		coordinate[j] = linind % f_source[j];
// 		linind = (linind-coordinate[j])/f_source[j];
// 	      }
// 	  }
	
// 	f_source.slice(dmn_number, coordinate, input_values);

// 	bool to_be_done = spline_input_values_to_wn(input_values);

// 	if(to_be_done)
// 	  {
// 	    S_wn.distribute(dmn_number, coordinate, &input_values[w::dmn_size()/2]);

// 	    perform_continuous_pole_expansion();

// 	    a_wn_distribute(dmn_number, coordinate);

// 	    a_x.distribute(dmn_number, coordinate, &a_x_ptr(0));

// 	    spline_a_x_to_output_values(output_values); 
	    
// 	    f_target.distribute(dmn_number, coordinate, output_values);
// 	  }
//       }
//   }

//   delete [] coordinate;
//   delete [] input_values;
//   delete [] output_values;
// }
