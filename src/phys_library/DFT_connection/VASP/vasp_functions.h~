//-*-C++-*-

#ifndef DFT_VASP_DATA_H
#define DFT_VASP_DATA_H

namespace DFT
{
  namespace VASP
  {

    struct t_ij_element
    {
      int    oi;
      int    oj;

      int    dRx;
      int    dRy;
      int    dRz;

//       double tijRe;
//       double tijIm;
 
      std::complex<double> t_ij;
    };

    bool operator<(const t_ij_element& lhs, const t_ij_element& rhs)
    {
      return (abs(lhs.t_ij)<abs(rhs.t_ij));
    }

    /*!
     *   \ingroup  PARAMETERS
     *
     *   \author   Peter Staar, Long Zhang
     *   \brief    ...
     */
    template<class parameters_type>
    class data
    {
#include "type_definitions.h"

    public:

      data(parameters_type& parameters_ref);

      ~data();

      void print();

      void construct_bloch_hamiltonians();

      void check_bloch_hamiltonians();

      void downfold_bloch_hamiltonians();

      void construct_t_ij();

    public:

      parameters_type& parameters;

      function<double, k_vasp> kx;
      function<double, k_vasp> ky;
      function<double, k_vasp> kz;

      function<double, dmn_2<k_vasp, b_vasp> > band_e;
      function<double, dmn_2<k_vasp, b_vasp> > band_o;

      function<double, dmn_3<k_vasp, b_vasp, o_vasp> > proj_magni; // proj_magni[nKpoints][nBands][nOrbi]
      function<double, dmn_3<k_vasp, b_vasp, o_vasp> > proj_phaRe; // proj_phaRe[nKpoints][nBands][nOrbi]
      function<double, dmn_3<k_vasp, b_vasp, o_vasp> > proj_phaIm; // proj_phaIm[nKpoints][nBands][nOrbi]

      function<double, dmn_3<k_vasp, b_dmft, o_dmft> > projection_re; // projection_Re[nKpoints][nCorrBands][nCorrOrbis]
      function<double, dmn_3<k_vasp, b_dmft, o_dmft> > projection_im; // projection_Im[nKpoints][nCorrBands][nCorrOrbis]

      function<double, dmn_3<k_vasp, b_dmft, b_dmft> > BlochHami   ; // BlochHami     [nKpoints][nCorrBands][nCorrBands]

      function<double, dmn_3<k_vasp, o_dmft, o_dmft> > dfBlochHami_re;// dfBlochHamiRe  [nKpoints][nCorrOrbis][nCorrOrbis]
      function<double, dmn_3<k_vasp, o_dmft, o_dmft> > dfBlochHami_im;// dfBlochHamiIm  [nKpoints][nCorrOrbis][nCorrOrbis]

      //function<double, dmn_3<k_vasp, b_dmft, b_dmft> > dfBlochHami_re;// dfBlochHamiRe  [nKpoints][nCorrOrbis][nCorrOrbis] 

      function<double, dmn_2<o_dmft, b_dmft> > p1_re;//[nCorrOrbis][nCorrBands];   // orbital x band
      function<double, dmn_2<o_dmft, b_dmft> > p1_im;//[nCorrOrbis][nCorrBands];

      function<double, dmn_2<b_dmft, o_dmft> > p2_re;//[nCorrBands][nCorrOrbis];   // band x orbital
      function<double, dmn_2<b_dmft, o_dmft> > p2_im;//[nCorrBands][nCorrOrbis];
      function<double, dmn_2<b_dmft, o_dmft> > p3_re;//[nCorrBands][nCorrOrbis];
      function<double, dmn_2<b_dmft, o_dmft> > p3_im;//[nCorrBands][nCorrOrbis];

      function<double, dmn_2<b_dmft, b_dmft> > nn_re;//[nCorrBands][nCorrBands];    // band x band
      function<double, dmn_2<b_dmft, b_dmft> > nn_im;//[nCorrBands][nCorrBands];

      function<double, dmn_2<o_dmft, o_dmft> > oo_re;//[nCorrOrbis][nCorrOrbis];    // obital x obital
      function<double, dmn_2<o_dmft, o_dmft> > oo_im;//[nCorrOrbis][nCorrOrbis];
      function<double, dmn_2<o_dmft, o_dmft> >  o_re;//[nCorrOrbis][nCorrOrbis];
      function<double, dmn_2<o_dmft, o_dmft> >  o_im;//[nCorrOrbis][nCorrOrbis];

      std::vector<int>    vec_oi;
      std::vector<int>    vec_oj;
      std::vector<int>    vec_dRx;
      std::vector<int>    vec_dRy;
      std::vector<int>    vec_dRz;
      std::vector<double> vec_tijRe;
      std::vector<double> vec_tijIm;
    };

    template<class parameters_type>
    data<parameters_type>::data(parameters_type& parameters_ref):
      parameters(parameters_ref),

      proj_magni("proj_magni"),

      proj_phaRe("proj_phaRe"),
      proj_phaIm("proj_phaIm"),

      projection_re("projection_re"),
      projection_im("projection_im"),

      BlochHami("BlochHami"),

      dfBlochHami_re("BlochHami_re"),
      dfBlochHami_im("BlochHami_im")
    {

    }

    template<class parameters_type>
    data<parameters_type>::~data()
    {
    }

    template<class parameters_type>
    void data<parameters_type>::print()
    {
      proj_magni.print_fingerprint();

      proj_phaRe.print_fingerprint();
      proj_phaIm.print_fingerprint();

      projection_re.print_fingerprint();
      projection_im.print_fingerprint();
    }


    template<class parameters_type>
    void data<parameters_type>::construct_bloch_hamiltonians()
    {
      cout << "\t" << __FUNCTION__ << endl;

      double norm=0;

      int corrband_min = parameters.get_lower_index_of_chosen_bands();
      int corrband_max = parameters.get_upper_index_of_chosen_bands();

      std::vector<int> CorrOrbiIndex = parameters.get_correlated_orbitals();

      for(int ik=0; ik<parameters.get_nKpoints(); ik++ )
        {
          for(int ib=0; ib<parameters.get_nBands(); ib++ )
            {
              if ( ib>=corrband_min && ib<=corrband_max )
                {      // chosen bands
                  for ( int io=0; io<CorrOrbiIndex.size(); io++ )
                    {    // chosen orbitals

                      norm = sqrt(   proj_phaRe(ik,ib,CorrOrbiIndex[io])*proj_phaRe(ik,ib,CorrOrbiIndex[io])
                                     + proj_phaIm(ik,ib,CorrOrbiIndex[io])*proj_phaIm(ik,ib,CorrOrbiIndex[io]) );

                      if ( norm < 1.0e-10 )
                        {     // my choice of 1.0e-10
                          projection_re(ik,ib-corrband_min,io) = 0.0;
                          projection_im(ik,ib-corrband_min,io) = 0.0;
                        }
                      else
                        {
                          projection_re(ik,ib-corrband_min,io)
                            = sqrt(proj_magni(ik,ib,CorrOrbiIndex[io])) * proj_phaRe(ik,ib,CorrOrbiIndex[io]) / norm;

                          projection_im(ik,ib-corrband_min,io)
                            = sqrt(proj_magni(ik,ib,CorrOrbiIndex[io])) * proj_phaIm(ik,ib,CorrOrbiIndex[io]) / norm;
                        }

                      if ( fabs(projection_re(ik,ib-corrband_min,io)) < 1.0e-10 )
                        projection_re(ik,ib-corrband_min,io) = 0.0;

                      if ( fabs(projection_im(ik,ib-corrband_min,io)) < 1.0e-10 )
                        projection_im(ik,ib-corrband_min,io) = 0.0;

                    } // chosen orbitals
                } // chosen bands

            }  // ib
        }  // ik

      for ( int ik=0; ik<parameters.get_nKpoints(); ik++ ) {
        for ( int ib=0;  ib<parameters.get_nBands();  ib++ ) {
          if ( ib>=corrband_min && ib<=corrband_max ) {
            BlochHami(ik,ib-corrband_min,ib-corrband_min) = band_e(ik,ib);
          }
        }
      }

    }

    template<class parameters_type>
    void data<parameters_type>::check_bloch_hamiltonians()
    {
      cout << "\t" << __FUNCTION__ << endl;

      //       double  p1_re[nCorrOrbis][nCorrBands];   // orbital x band
      //       double  p1_im[nCorrOrbis][nCorrBands];

      //       double  p2_re[nCorrBands][nCorrOrbis];   // band x orbital
      //       double  p2_im[nCorrBands][nCorrOrbis];
      //       double  p3_re[nCorrBands][nCorrOrbis];
      //       double  p3_im[nCorrBands][nCorrOrbis];

      //       double nn_re[nCorrBands][nCorrBands];    // band x band
      //       double nn_im[nCorrBands][nCorrBands];

      //       double oo_re[nCorrOrbis][nCorrOrbis];    // obital x obital
      //       double oo_im[nCorrOrbis][nCorrOrbis];
      //       double  o_re[nCorrOrbis][nCorrOrbis];
      //       double  o_im[nCorrOrbis][nCorrOrbis];

      double xx, yy;

      for ( int ib=0; ib<b_dmft::dmn_size(); ib++ ) {    // no x nb, zero
        for ( int io=0; io<o_dmft::dmn_size(); io++ ) {
          p1_re(io,ib) = 0.;
          p1_im(io,ib) = 0.;
          p2_re(ib,io) = 0.;
          p2_im(ib,io) = 0.;
        }
      }

      for ( int i=0; i<b_dmft::dmn_size(); i++ ) {       // nb x nb, diagonal unit
        for ( int j=0; j<b_dmft::dmn_size(); j++ ) {
          nn_re(i,j) = 0.;
          nn_im(i,j) = 0.;
          if (i==j) nn_re(i,j) = 1.0;
        }
      }

      for ( int i=0; i<o_dmft::dmn_size(); i++ ) {       // no x no, zero
        for ( int j=0; j<o_dmft::dmn_size(); j++ ) {
          oo_re(i,j) = 0.;
          oo_im(i,j) = 0.;
          o_re(i,j) = 0.;
          o_im(i,j) = 0.;
        }
      }

      // p1 = p(k)
      // p2 = p_adjoint(k)
      // oo = p1 * ( nn(k) * p2 )

      // loop k
      for ( int ik=0; ik<parameters.get_nKpoints(); ik++ ) {

        // -----------------------------------
        for ( int ib=0; ib<b_dmft::dmn_size(); ib++ ) {         // p1 and p2
          for ( int io=0; io<o_dmft::dmn_size(); io++ ) {

            p1_re(io,ib) =  projection_re(ik,ib,io);
            p1_im(io,ib) =  projection_im(ik,ib,io);

            p2_re(ib,io) =  p1_re(io,ib);
            p2_im(ib,io) = -p1_im(io,ib);
          }
        }

        // -----------------------------------
        for ( int io=0; io<o_dmft::dmn_size(); io++ ) {         // p3 = nn(k) * p2
          for ( int ib=0; ib<b_dmft::dmn_size(); ib++ ) {

            xx = 0.;
            yy = 0.;
            for ( int l=0; l<b_dmft::dmn_size(); l++ ) {
              xx = xx + ( nn_re(ib,l)*p2_re(l,io) - nn_im(ib,l)*p2_im(l,io) );
              yy = yy + ( nn_im(ib,l)*p2_re(l,io) + nn_re(ib,l)*p2_im(l,io) );
            }
            p3_re(ib,io) = xx;
            p3_im(ib,io) = yy;

          }
        }

        // -----------------------------------
        for ( int i=0; i<o_dmft::dmn_size(); i++ ) {           // oo = p1 * p3
          for ( int j=0; j<o_dmft::dmn_size(); j++ ) {

            xx = 0.;
            yy = 0.;
            for ( int l=0; l<b_dmft::dmn_size(); l++ ) {
              xx = xx + ( p1_re(i,l)*p3_re(l,j) - p1_im(i,l)*p3_im(l,j) );
              yy = yy + ( p1_im(i,l)*p3_re(l,j) + p1_re(i,l)*p3_im(l,j) );
            }
            oo_re(i,j) = xx;
            oo_im(i,j) = yy;

          }
        }

        // -----------------------------------  scale the projection
        double scale[o_dmft::dmn_size()];
        for ( int io=0; io<o_dmft::dmn_size(); io++ ) {
          scale[io] = sqrt( fabs( oo_re(io,io) ) );
          if (scale[io]<1.0e-8) scale[io]=1.0;
        }
        for ( int io=0; io<o_dmft::dmn_size(); io++ ) {
          for ( int ib=0; ib<b_dmft::dmn_size(); ib++ ) {
            projection_re(ik,ib,io) = projection_re(ik,ib,io) / scale[io] ;
            projection_im(ik,ib,io) = projection_im(ik,ib,io) / scale[io] ;
          }
        }

        // -----------------------------------
        for ( int i=0; i<o_dmft::dmn_size(); i++ ) {           // k sum
          for ( int j=0; j<o_dmft::dmn_size(); j++ ) {
            o_re(i,j) = o_re(i,j) + oo_re(i,j);
            o_im(i,j) = o_im(i,j) + oo_im(i,j);
          }
        }

      }  // loop k

    }

    template<class parameters_type>
    void data<parameters_type>::downfold_bloch_hamiltonians()
    {
      cout << "\t" << __FUNCTION__ << endl;

      double xx, yy;

      for ( int ik=0; ik<parameters.get_nKpoints(); ik++ ) {

        // p1 and p2
        for ( int ib=0; ib<b_dmft::dmn_size(); ib++ ) {
          for ( int io=0; io<o_dmft::dmn_size(); io++ ) {
            p1_re(io,ib) =  projection_re(ik,ib,io);
            p1_im(io,ib) =  projection_im(ik,ib,io);

            p2_re(ib,io) =  p1_re(io,ib);
            p2_im(ib,io) = -p1_im(io,ib);
          }
        }

        // p3 = BH(k) * p2
        for ( int io=0; io<o_dmft::dmn_size(); io++ ) {
          for ( int ib=0; ib<b_dmft::dmn_size(); ib++ ) {
            xx = 0.;
            yy = 0.;
            for ( int l=0; l<b_dmft::dmn_size(); l++ ) {
              xx = xx + ( BlochHami(ik,ib,l)*p2_re(l,io) );
              yy = yy + ( BlochHami(ik,ib,l)*p2_im(l,io) );
            }
            p3_re(ib,io) = xx;
            p3_im(ib,io) = yy;

          }
        }

        // dfBH(k) = p1 * p3
        for ( int i=0; i<o_dmft::dmn_size(); i++ ) {
          for ( int j=0; j<o_dmft::dmn_size(); j++ ) {
            xx = 0.;
            yy = 0.;
            for ( int l=0; l<b_dmft::dmn_size(); l++ ) {
              xx = xx + ( p1_re(i,l)*p3_re(l,j) - p1_im(i,l)*p3_im(l,j) );
              yy = yy + ( p1_im(i,l)*p3_re(l,j) + p1_re(i,l)*p3_im(l,j) );
            }
            
	    dfBlochHami_re(ik,i,j) = xx;
            dfBlochHami_im(ik,i,j) = yy;
          }
        }

      }

    }

    template<class parameters_type>
    void data<parameters_type>::construct_t_ij()
    {
      cout << "\t" << __FUNCTION__ << endl;

      //       std::vector<int>    vec_oi;
      //       std::vector<int>    vec_oj;
      //       std::vector<int>    vec_dRx;
      //       std::vector<int>    vec_dRy;
      //       std::vector<int>    vec_dRz;
      //       std::vector<double> vec_tijRe;
      //       std::vector<double> vec_tijIm;

      double KK=1.0/parameters.get_nKpoints();

      int dRx, dRy, dRz;

      std::complex<double> tij;

      // loop neighbor unit cells
      for (int a=-parameters.get_nr(); a<=parameters.get_nr(); a++) {
        for (int b=-parameters.get_nr(); b<=parameters.get_nr(); b++) {
          for (int c=-parameters.get_nr(); c<=parameters.get_nr(); c++) {

            dRx = a;
            dRy = b;
            dRz = c;

            // loop oi, oj, - orbital pairs between the 2 sites
            for (int oi=0; oi<o_dmft::dmn_size(); oi++) {
              for (int oj=0; oj<o_dmft::dmn_size(); oj++) {

                tij = std::complex<double>(0.0,0.0);
                for (int k=0; k<parameters.get_nKpoints(); k++) {
                  double kdotdR = 2.0 * M_PI * (kx(k)*dRx + ky(k)*dRy + kz(k)*dRz);      // k.dot.dR
                  tij = tij + ( std::complex<double>( cos(kdotdR), sin(kdotdR) ) *
                                std::complex<double>( dfBlochHami_re(k,oi,oj), dfBlochHami_im(k,oi,oj)) );
                }
                tij = tij * KK;

                vec_oi.push_back(oi);
                vec_oj.push_back(oj);
                vec_dRx.push_back(dRx);
                vec_dRy.push_back(dRy);
                vec_dRz.push_back(dRz);
                vec_tijRe.push_back(tij.real());
                vec_tijIm.push_back(tij.imag());

                // for SrVO3, one can compare some value with paper
                // if ( a==1 && b==0 && c==1 && oi==1 && oj==1 )
                //   cout << "\n ------- \n" << tij << "\n ------- \n" << endl;


              } // oj
            } // oi



          } // c
        } // b
      } // a


      std::sort(t_ij_vector.begin(), t_ij_vector.end());

    }

  }

}

#endif

