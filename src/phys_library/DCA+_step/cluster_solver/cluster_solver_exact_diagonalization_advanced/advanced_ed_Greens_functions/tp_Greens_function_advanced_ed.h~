//-*-C++-*-

#ifndef ADVANCED_FERMIONIC_TP_GREENS_FUNCTION_H
#define ADVANCED_FERMIONIC_TP_GREENS_FUNCTION_H

namespace DCA
{
  namespace ADVANCED_EXACT_DIAGONALIZATION
  {
    template<typename parameter_type, typename ed_options>
    class fermionic_tp_Greens_function
    {
#include "type_definitions.h"

      //typedef ED_type_definitions<parameter_type, b_dmn, s_dmn, r_dmn> ED_type_def;

      typedef typename ed_options::b_dmn b_dmn;
      typedef typename ed_options::s_dmn s_dmn;
      typedef typename ed_options::r_dmn r_dmn;
      typedef typename ed_options::k_dmn k_dmn;

      typedef typename ed_options::profiler_t       profiler_t;
      typedef typename ed_options::concurrency_type concurrency_type;

      typedef typename ed_options::scalar_type  scalar_type;
      typedef typename ed_options::complex_type complex_type;

      typedef typename ed_options::vector_type         vector_type;
      typedef typename ed_options::matrix_type         matrix_type;
      typedef typename ed_options::int_matrix_type int_matrix_type;

      typedef typename ed_options::nu_dmn nu_dmn;
      typedef typename ed_options::b_s_r  b_s_r_dmn_type;

      typedef typename ed_options::bs_dmn_type  bs_dmn_type;

      typedef typename ed_options::bsr_dmn_type bsr_dmn_type;
      typedef typename ed_options::bsk_dmn_type bsk_dmn_type;

      typedef typename ed_options::nu_nu_r_dmn_type nu_nu_r_dmn_type;

      typedef fermionic_Hamiltonian     <parameter_type, ed_options> fermionic_Hamiltonian_type;
      typedef fermionic_overlap_matrices<parameter_type, ed_options> fermionic_overlap_type;

      typedef Fock_space   <parameter_type, ed_options> fermionic_Fock_space_type;
      typedef Hilbert_space<parameter_type, ed_options> Hilbert_space_type;

      typedef dmn_0<fermionic_Fock_space_type>          fermionic_Fock_dmn_type;

      typedef tp_Greens_function_data<ed_options> tp_Greens_function_data_type;

    public:

      fermionic_tp_Greens_function(parameter_type&             parameters_ref,
                                   fermionic_Hamiltonian_type& Hamiltonian_ref,
                                   fermionic_overlap_type&     overlap_ref);

      ~fermionic_tp_Greens_function();

      void compute_non_local_Greens_function(bool interacting);

    private:

      /*!
       *  new functions ...
       */
      void compute_real_space_Greens_functions(bool interacting);

      void renormalize_real_space_Greens_functions(bool interacting);

      void compute_Greens_functions_ac_slow(std::vector<tp_Greens_function_data_type>& data_vec);

      void compute_Greens_functions_ca_slow(std::vector<tp_Greens_function_data_type>& data_vec);

      void compute_tp_nonlocal_Greens_function(bool is_ac, int bsr_i, int bsr_j,
                                               scalar_type  E_0,
                                               scalar_type  E_1,
                                               complex_type factor,
                                               tp_Greens_function_data_type& data);

    private:

      parameter_type&   parameters;
      concurrency_type& concurrency;

      double CUT_OFF;

      fermionic_Hamiltonian_type& Hamiltonian;
      fermionic_overlap_type&     overlap;

      function<vector_type, fermionic_Fock_dmn_type >& eigen_energies;
      function<matrix_type, fermionic_Fock_dmn_type >& eigen_states;

      function<int, dmn_3<fermionic_Fock_dmn_type, fermionic_Fock_dmn_type, b_s_r_dmn_type> >& creation_set_all;
      function<int, dmn_3<fermionic_Fock_dmn_type, fermionic_Fock_dmn_type, b_s_r_dmn_type> >& annihilation_set_all;

      function<int, dmn_2<r_dmn, r_dmn> > rj_minus_ri;

      function<complex_type, dmn_4<w_VERTEX_EXTENDED, w_VERTEX_EXTENDED, bsr_dmn_type, bsr_dmn_type> > G_non_w_w_r_r_nonlocal;
      function<complex_type, dmn_4<w_VERTEX_EXTENDED, w_VERTEX_EXTENDED, bsk_dmn_type, bsk_dmn_type> > G_non_w_w_k_k_nonlocal;

      function<complex_type, dmn_4<w_VERTEX_EXTENDED, w_VERTEX_EXTENDED, bsr_dmn_type, bsr_dmn_type> > G_int_w_w_r_r_nonlocal;
      function<complex_type, dmn_4<w_VERTEX_EXTENDED, w_VERTEX_EXTENDED, bsk_dmn_type, bsk_dmn_type> > G_int_w_w_k_k_nonlocal;
    };

    template<typename parameter_type, typename ed_options>
    fermionic_tp_Greens_function<parameter_type, ed_options>::fermionic_tp_Greens_function(parameter_type&             parameters_ref,
                                                                                           fermionic_Hamiltonian_type& Hamiltonian_ref,
                                                                                           fermionic_overlap_type&     overlap_ref):
      parameters(parameters_ref),
      concurrency(parameters.get_concurrency()),

      CUT_OFF(parameters.get_eigenvalue_cut_off()),

      Hamiltonian(Hamiltonian_ref),
      overlap(overlap_ref),

      //       ac_Hilbert_space_indices(0),
      //       ca_Hilbert_space_indices(0),

      eigen_energies(Hamiltonian.get_eigen_energies()),
      eigen_states  (Hamiltonian.get_eigen_states()),

      creation_set_all    (overlap.get_creation_set_all()),
      annihilation_set_all(overlap.get_annihilation_set_all()),

      rj_minus_ri("rj_minus_ri"),

      G_non_w_w_r_r_nonlocal("G_non_w_w_r_r_nonlocal"),
      G_non_w_w_k_k_nonlocal("G_non_w_w_r_r_nonlocal"),

      G_int_w_w_r_r_nonlocal("G_int_w_w_r_r_nonlocal"),
      G_int_w_w_k_k_nonlocal("G_int_w_w_r_r_nonlocal")
    {
      for(int ri=0; ri<r_dmn::dmn_size(); ri++)
        for(int rj=0; rj<r_dmn::dmn_size(); rj++)
          rj_minus_ri(ri, rj) = r_dmn::parameter_type::subtract(ri, rj);
    }

    template<typename parameter_type, typename ed_options>
    fermionic_tp_Greens_function<parameter_type, ed_options>::~fermionic_tp_Greens_function()
    {}

    template<typename parameter_type, typename ed_options>
    void fermionic_tp_Greens_function<parameter_type, ed_options>::compute_non_local_Greens_function(bool interacting)
    {
      compute_real_space_Greens_functions    (interacting);
      renormalize_real_space_Greens_functions(interacting);

      if(interacting)
        {
          MATH_ALGORITHMS::TRANSFORM<r_dmn, k_dmn>::execute_on_all(G_int_w_w_r_r_nonlocal, G_int_w_w_k_k_nonlocal);
        }
      else
        {
          MATH_ALGORITHMS::TRANSFORM<r_dmn, k_dmn>::execute_on_all(G_non_w_w_r_r_nonlocal, G_non_w_w_k_k_nonlocal);
        }

      if(false)
        {
          for(int bsr_i=0; bsr_i<bsr_dmn_type::dmn_size(); bsr_i++){
            for(int w_i=0; w_i<w_VERTEX_EXTENDED::dmn_size(); w_i++){

              for(int bsr_j=0; bsr_j<bsr_dmn_type::dmn_size(); bsr_j++){
                for(int w_j=0; w_j<w_VERTEX_EXTENDED::dmn_size(); w_j++){

                  cout << "\t" << real(G_non_w_w_r_r_nonlocal(w_i, w_j, bsr_i, bsr_j));
                }
              }
              cout << "\n";
            }
          }
          cout << "\n";

          //SHOW::execute(G_nonlocal);
        }

      if(interacting and true)
        {
          for(int bsr_i=0; bsr_i<bsr_dmn_type::dmn_size(); bsr_i++){

            //cout << "\n\t" << bsr_i << " : \n\n";
            cout << "\n";
            for(int w_i=0; w_i<w_VERTEX_EXTENDED::dmn_size(); w_i++){

              for(int bsr_j=0; bsr_j<bsr_dmn_type::dmn_size(); bsr_j++){
                cout << "\t";

                for(int w_j=0; w_j<w_VERTEX_EXTENDED::dmn_size(); w_j++){
                  if(abs(real(G_int_w_w_k_k_nonlocal(w_i, w_j, bsr_i, bsr_j)))<1.e-6)
                    cout << "\t" << 0.0;
                  else
                    cout << "\t" << real(G_int_w_w_k_k_nonlocal(w_i, w_j, bsr_i, bsr_j));
                }
              }
              cout << "\n";
            }
          }
          cout << "\n\n\n\n";

          //SHOW::execute(G_nonlocal);
        }

      if(interacting and true)
        {
          for(int bsr_i=0; bsr_i<bsr_dmn_type::dmn_size(); bsr_i++){

            //cout << "\n\t" << bsr_i << " : \n\n";

            cout << "\n";
            for(int w_i=0; w_i<w_VERTEX_EXTENDED::dmn_size(); w_i++){

              for(int bsr_j=0; bsr_j<bsr_dmn_type::dmn_size(); bsr_j++){
                cout << "\t";

                for(int w_j=0; w_j<w_VERTEX_EXTENDED::dmn_size(); w_j++){
                  if(abs(imag(G_int_w_w_k_k_nonlocal(w_i, w_j, bsr_i, bsr_j)))<1.e-6)
                    cout << "\t" << 0.0;
                  else
                    cout << "\t" << imag(G_int_w_w_k_k_nonlocal(w_i, w_j, bsr_i, bsr_j));
                }
              }
              cout << "\n";
            }
          }
          cout << "\n\n\n\n";

          //SHOW::execute(G_nonlocal);
        }

      //assert(false);
    }

    template<typename parameter_type, typename ed_options>
    void fermionic_tp_Greens_function<parameter_type, ed_options>::compute_real_space_Greens_functions(bool interacting)
    {
      if(concurrency.id()==0)
        cout << "\n\t" << __FUNCTION__ << endl;

      if(interacting)
        {
          G_int_w_w_r_r_nonlocal = 0;
          G_int_w_w_k_k_nonlocal = 0;
        }
      else
        {
          G_non_w_w_r_r_nonlocal = 0;
          G_non_w_w_k_k_nonlocal = 0;
        }

      int start = clock();

      {
        int n_threads = 1;

        std::vector<tp_Greens_function_data_type> data_vec(n_threads);

        for(int l=0; l<n_threads; l++)
          data_vec[l].initialize(parameters);

        compute_Greens_functions_ac_slow(data_vec);
        compute_Greens_functions_ca_slow(data_vec);

        for(int l=0; l<n_threads; l++)
          if(interacting)
            data_vec[l].sum_to(G_int_w_w_r_r_nonlocal);
          else
            data_vec[l].sum_to(G_non_w_w_r_r_nonlocal);
      }

      int end = clock();

      if(concurrency.id()==0)
        cout << "\t " << __FUNCTION__ << "total time : " << double(end-start)/double(CLOCKS_PER_SEC) << "\n\n";
    }

    template<typename parameter_type, typename ed_options>
    void fermionic_tp_Greens_function<parameter_type, ed_options>::renormalize_real_space_Greens_functions(bool interacting)
    {
      cout << __FUNCTION__ << endl;

      std::vector< Hilbert_space_type >& Hilbert_spaces = fermionic_Fock_dmn_type::get_elements();

      double beta = parameters.get_beta();

      double Z = 0;
      for(int HS_i = 0; HS_i < Hilbert_spaces.size(); ++HS_i)
        for(int n = 0; n < Hilbert_spaces[HS_i].size(); ++n)
          Z += std::exp(-beta*eigen_energies(HS_i)[n]);

      double factor = 1./Z;

      if(interacting)
        G_int_w_w_r_r_nonlocal *= factor;
      else
        G_non_w_w_r_r_nonlocal *= factor;
    }


    template<typename parameter_type, typename ed_options>
    void fermionic_tp_Greens_function<parameter_type, ed_options>::compute_Greens_functions_ac_slow(std::vector<tp_Greens_function_data_type>& data_vec)
    {
      cout << "\n\n\t" << __FUNCTION__ << "\n\n";

      std::vector< Hilbert_space_type >& Hilbert_spaces = fermionic_Fock_dmn_type::get_elements();

      scalar_type beta = parameters.get_beta();

      double zero=0, nonzero=0;

      for(int HS_0 = 0; HS_0 < Hilbert_spaces.size(); ++HS_0)
        {
          for(int HS_1 = 0; HS_1 < Hilbert_spaces.size(); ++HS_1)
            {
              for(int bsr_i = 0; bsr_i < b_s_r_dmn_type::dmn_size(); ++bsr_i)
                {
                  for(int bsr_j = 0; bsr_j < b_s_r_dmn_type::dmn_size(); ++bsr_j)
                    {
                      tp_Greens_function_data_type& data = data_vec[0];

                      bool done = false;

                      if(annihilation_set_all(HS_0, HS_1, bsr_i) != -1 &&
                         creation_set_all    (HS_1, HS_0, bsr_j) != -1)
                        {
                          for(int n0 = 0; n0 < Hilbert_spaces[HS_0].size(); ++n0)
                            {
                              scalar_type E_n0 = eigen_energies(HS_0)[n0];
                              scalar_type w_e  = std::exp(-beta*E_n0);

                              if(w_e > CUT_OFF)
                                {
                                  for(int n1 = 0; n1 < Hilbert_spaces[HS_1].size(); ++n1)
                                    {
                                      if(not done)
                                        {
                                          overlap.compute_annihilation_matrix_fast(HS_0, HS_1, bsr_i, data.annihilation_bsr_i, data.tmp);
                                          overlap.compute_creation_matrix_fast    (HS_1, HS_0, bsr_j, data.creation_bsr_j    , data.tmp);

                                          done = true;
                                        }

                                      scalar_type E_n1 = eigen_energies(HS_1)[n1];

                                      complex_type factor = w_e * data.annihilation_bsr_i(n0,n1) * data.creation_bsr_j(n1,n0);

                                      if(abs(factor) > CUT_OFF)
                                        {
                                          nonzero += 1;

                                          compute_tp_nonlocal_Greens_function(true, bsr_i, bsr_j, E_n0, E_n1, factor, data);
                                        }
                                      else
                                        {
                                          zero += 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

      cout << "\n\t nonzero/total : " << nonzero/(zero+nonzero) << "\n";
    }

    template<typename parameter_type, typename ed_options>
    void fermionic_tp_Greens_function<parameter_type, ed_options>::compute_Greens_functions_ca_slow(std::vector<tp_Greens_function_data_type>& data_vec)
    {
      cout << "\n\n\t" << __FUNCTION__ << "\n\n";

      std::vector<Hilbert_space_type>& Hilbert_spaces = fermionic_Fock_dmn_type::get_elements();

      scalar_type beta = parameters.get_beta();

      double zero=0, nonzero=0;

      for(int HS_0=0; HS_0<Hilbert_spaces.size(); ++HS_0)
        {
          for(int HS_1=0; HS_1<Hilbert_spaces.size(); ++HS_1)
            {
              for(int bsr_i = 0; bsr_i < b_s_r_dmn_type::dmn_size(); ++bsr_i)
                {
                  for(int bsr_j = 0; bsr_j < b_s_r_dmn_type::dmn_size(); ++bsr_j)
                    {
                      tp_Greens_function_data_type& data = data_vec[0];

                      bool done = false;

                      if(annihilation_set_all(HS_1, HS_0, bsr_i) != -1 &&
                         creation_set_all    (HS_0, HS_1, bsr_j) != -1)
                        {
                          for(int n0=0; n0<Hilbert_spaces[HS_0].size(); ++n0)
                            {
                              scalar_type E_n0 = eigen_energies(HS_0)[n0];
                              scalar_type w_e  = std::exp(-beta*E_n0);

                              if(w_e > CUT_OFF)
                                {
                                  for(int n1=0; n1<Hilbert_spaces[HS_1].size(); ++n1)
                                    {
                                      if(not done)
                                        {
                                          overlap.compute_annihilation_matrix_fast(HS_1, HS_0, bsr_i, data.annihilation_bsr_i, data.tmp);
                                          overlap.compute_creation_matrix_fast    (HS_0, HS_1, bsr_j, data.creation_bsr_j    , data.tmp);

                                          done = true;
                                        }

                                      scalar_type E_n1 = eigen_energies(HS_1)[n1];

                                      complex_type factor = w_e * data.creation_bsr_j(n0,n1) * data.annihilation_bsr_i(n1,n0);

                                      if(abs(factor) > CUT_OFF)
                                        {
                                          nonzero += 1;

                                          compute_tp_nonlocal_Greens_function(false, bsr_i, bsr_j, E_n0, E_n1, factor, data);

                                        }
                                      else
                                        {
                                          zero += 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

      cout << "\n\t nonzero/total : " << nonzero/(zero+nonzero) << "\n";
    }

    template<typename parameter_type, typename ed_options>
    void fermionic_tp_Greens_function<parameter_type, ed_options>::compute_tp_nonlocal_Greens_function(bool is_ac,
                                                                                                       int bsr_i, int bsr_j,
                                                                                                       scalar_type  E_0,
                                                                                                       scalar_type  E_1,
                                                                                                       complex_type factor,
                                                                                                       tp_Greens_function_data_type& data)
    {
      scalar_type ONE(1);

      if(is_ac)
        {
          for(int w_i=0; w_i<w_VERTEX_EXTENDED::dmn_size(); ++w_i){
            for(int w_j=0; w_j<w_VERTEX_EXTENDED::dmn_size(); ++w_j){
              data.G_wm_wn(w_i, w_j) = ONE/(data.w_im(w_i) + (E_0-E_1) );//*ONE/(data.w_im(w_j) - (E_0-E_1) );
            }
          }
        }
      else
        {
          for(int w_i=0; w_i<w_VERTEX_EXTENDED::dmn_size(); ++w_i){
            for(int w_j=0; w_j<w_VERTEX_EXTENDED::dmn_size(); ++w_j){
              data.G_wm_wn(w_i, w_j) = ONE/(data.w_im(w_j) - (E_0-E_1) );//*ONE/(data.w_im(w_j) + (E_0-E_1));
            }
          }
        }

      for(int w_i=0; w_i<w_VERTEX_EXTENDED::dmn_size(); ++w_i)
        for(int w_j=0; w_j<w_VERTEX_EXTENDED::dmn_size(); ++w_j)
          data.G_nonlocal(w_i, w_j, bsr_i, bsr_j) += factor * data.G_wm_wn(w_i, w_j);
    }

  }

}

#endif
