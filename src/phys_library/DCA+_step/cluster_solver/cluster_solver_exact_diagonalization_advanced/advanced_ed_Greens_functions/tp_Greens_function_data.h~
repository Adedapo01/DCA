//-*-C++-*-

#ifndef ADVANCED_FERMIONIC_TP_GREENS_FUNCTION_DATA_H
#define ADVANCED_FERMIONIC_TP_GREENS_FUNCTION_DATA_H

namespace DCA
{
  namespace ADVANCED_EXACT_DIAGONALIZATION
  {
    template<typename ed_options>
    class tp_Greens_function_data
    {
#include "type_definitions.h"

      typedef typename ed_options::b_dmn b_dmn;
      typedef typename ed_options::s_dmn s_dmn;
      typedef typename ed_options::r_dmn r_dmn;
      typedef typename ed_options::k_dmn k_dmn;

      typedef typename ed_options::profiler_t       profiler_t;
      typedef typename ed_options::concurrency_type concurrency_type;

      typedef typename ed_options::scalar_type  scalar_type;
      typedef typename ed_options::complex_type complex_type;

      typedef typename ed_options::vector_type         vector_type;
      typedef typename ed_options::matrix_type         matrix_type;
      typedef typename ed_options::int_matrix_type int_matrix_type;

      typedef typename ed_options::nu_dmn nu_dmn;
      typedef typename ed_options::b_s_r  b_s_r_dmn_type;

      typedef typename ed_options::bs_dmn_type  bs_dmn_type;
      typedef typename ed_options::bsr_dmn_type bsr_dmn_type;

      typedef typename ed_options::nu_nu_r_dmn_type nu_nu_r_dmn_type;

      typedef tp_Greens_function_data<ed_options> this_type;

      typedef dmn_2<w_VERTEX_EXTENDED, w_VERTEX_EXTENDED> wm_wn_dmn_type;
      
    public:

      tp_Greens_function_data();

      tp_Greens_function_data(const this_type& other);

      ~tp_Greens_function_data();

//       this_type& operator=(      this_type& other);
//       this_type& operator=(const this_type& other);

      void set_indices(int l);

      template<typename parameter_type>
      void initialize(parameter_type& parameters);

      void sum_to(function<complex_type, dmn_4<w_VERTEX_EXTENDED, w_VERTEX_EXTENDED, bsr_dmn_type, bsr_dmn_type> >& G_nonlocal);

//       void sum_to(function<std::complex<double>, dmn_4<nu_dmn, nu_dmn, r_dmn, w     > >& G_r_w,
//                   function<std::complex<double>, dmn_4<nu_dmn, nu_dmn, r_dmn, w_REAL> >& G_r_w_real,
//                   function<             double , dmn_4<nu_dmn, nu_dmn, r_dmn, t     > >& G_r_t);

    public:

      int b_i;
      int s_i;

      int b_j;
      int s_j;

      int r_i;
      int r_j;

      int delta_r;

      int nu_i;
      int nu_j;

      int bsr_i;
      int bsr_j;

      bs_dmn_type  bs_dmn;
      bsr_dmn_type bsr_dmn;

      nu_nu_r_dmn_type nu_nu_r_dmn;

      matrix_type tmp;

      matrix_type annihilation_bsr_i;
      matrix_type creation_bsr_j;

      function<complex_type, w_VERTEX_EXTENDED> w_im;
      function<complex_type, w_VERTEX_EXTENDED> G_wm;

      function<complex_type, dmn_4<w_VERTEX_EXTENDED, w_VERTEX_EXTENDED, bsr_dmn_type, bsr_dmn_type> > G_nonlocal;
    };

    template<typename ed_options>
    tp_Greens_function_data<ed_options>::tp_Greens_function_data()
    {}

    template<typename ed_options>
    tp_Greens_function_data<ed_options>::tp_Greens_function_data(const this_type& other)
    {}
    
    template<typename ed_options>
    tp_Greens_function_data<ed_options>::~tp_Greens_function_data()
    {}

    template<typename ed_options>
    template<typename parameter_type>
    void tp_Greens_function_data<ed_options>::initialize(parameter_type& parameters)
    {
      complex_type I(0,1);

      for(int w_i=0; w_i<w_VERTEX_EXTENDED::dmn_size(); ++w_i)
        w_im(w_i) = I*w_VERTEX_EXTENDED::get_elements()[w_i];

      G_nonlocal = 0;
    }

//     template<typename ed_options>
//     void tp_Greens_function_data<ed_options>::set_indices(int l)
//     {
//       int indices[5];

//       nu_nu_r_dmn.linind_2_subind(l, indices);

//       b_i = indices[0];
//       s_i = indices[1];

//       b_j = indices[2];
//       s_j = indices[3];

//       r_i = r_dmn::parameter_type::origin_index();
//       r_j = indices[4];

//       delta_r = r_j;

//       nu_i = bs_dmn(b_i, s_i);
//       nu_j = bs_dmn(b_j, s_j);

//       bsr_i = bsr_dmn(b_i, s_i, r_i);
//       bsr_j = bsr_dmn(b_j, s_j, r_j);
//     }

    template<typename ed_options>
    void tp_Greens_function_data<ed_options>::sum_to(function<complex_type, dmn_4<w_VERTEX_EXTENDED, w_VERTEX_EXTENDED, bsr_dmn_type, bsr_dmn_type> >& G_nonlocal_ref)
    {
      G_nonlocal_ref += G_nonlocal;
    }

//     template<typename ed_options>
//     void tp_Greens_function_data<ed_options>::sum_to(function<std::complex<double>, dmn_4<nu_dmn, nu_dmn, r_dmn, w     > >& G_r_w_im,
//                                                      function<std::complex<double>, dmn_4<nu_dmn, nu_dmn, r_dmn, w_REAL> >& G_r_w_re,
//                                                      function<             double , dmn_4<nu_dmn, nu_dmn, r_dmn, t     > >& G_r_t)
//     {
//       for(int ind=0; ind<nu_nu_r_dmn_type::dmn_size(); ind++)
//         {
//           set_indices(ind);

// 	  cout << ind << "\t" << nu_i << ", " << nu_j << ", " << delta_r << endl;

//           for(int t_i = t::dmn_size()/2; t_i<t::dmn_size(); ++t_i)
//             G_r_t(nu_i, nu_j, delta_r, t_i) += G_tau__nu_nu_r(t_i, ind);

//           for(int w_i=0; w_i<w::dmn_size(); ++w_i)
//             G_r_w_im(nu_i, nu_j, delta_r, w_i) += G_w_im__nu_nu_r(w_i, ind);

//           for(int w_i=0; w_i<w_REAL::dmn_size(); ++w_i)
//             G_r_w_re(nu_i, nu_j, delta_r, w_i) += G_w_re__nu_nu_r(w_i, ind);
//         }

//     }

  }

}

#endif
