//-*-C++-*-

#ifndef SS_HYBRIDIZATION_ACCUMULATOR_SP_NFFT_H
#define SS_HYBRIDIZATION_ACCUMULATOR_SP_NFFT_H

namespace DCA
{
  namespace QMCI
  {
    /*!
     *  \brief   This class organizes the measurements in the single-site hybridization QMC
     *  \author  Peter Staar
     *  \author  Bart Ydens
     *  \version 1.0
     *
     *
     *
     * The impurity self-energy can be expressed in the following form:
     * \f{eqnarray*}{
     * \Sigma_{ab}(i \nu) = \frac12 \sum_{ij} G^{-1}_{ai}(i \nu)(U_{jb} + U_{bj}) F_{ib}^j(i \nu)
     * \f}
     * Where the impurity Green function \f$G_{ab}(\tau)\f$ is measured according to
     * \f{eqnarray*}{
     * G_{ab}(\tau) = -\frac{1}{\beta} \left< \sum_{\alpha \beta = 1}^{n} M_{\alpha \beta} \delta^{-}(\tau - (\tau'_{\alpha} - \tau_{\beta}) \delta_{a,\alpha} \delta_{b,\beta} \right>_{MC}
     * \f}
     * and the correlation function \f$F_{ab}^j(\tau)\f$ is measured according to
     * \f{eqnarray*}{
     * F_{ab}^j(\tau) = -\frac{1}{\beta} \left< \sum_{\alpha \beta = 1}^{n} M_{\alpha \beta} \delta^{-}(\tau - (\tau'_{\alpha} - \tau_{\beta}) n_j(\tau_{\beta}) \delta_{a,\alpha} \delta_{b,\beta} \right>_{MC}
     * \f}
     * where
     * \f{eqnarray*}{
     * \delta^{\pm}(\tau) = \sum_{n} (\pm1)^n \delta(\tau - n\beta)
     * \f}
     *
     */
    template<class parameters_type, class base_cluster_type>
    class MC_single_particle_accumulator<SS_CT_HYB, NFFT, parameters_type, base_cluster_type>
    {
#include "type_definitions.h"

      typedef r_cluster<FULL, base_cluster_type> r_cluster_type;
      typedef k_cluster<FULL, base_cluster_type> k_cluster_type;

      typedef dmn_0<r_cluster_type> r_dmn_t;
      typedef dmn_0<k_cluster_type> k_dmn_t;

      typedef typename parameters_type::profiler_type    profiler_type;
      typedef typename parameters_type::Concurrency_Type concurrency_type;

      typedef typename parameters_type::MC_measurement_scalar_type  scalar_type;

    public:

      MC_single_particle_accumulator(parameters_type&   parameters_ref);

      ~MC_single_particle_accumulator();

      void initialize(function<std::complex<double>, dmn_4<nu, nu, r_dmn_t, w> >& G_r_w,
                      function<std::complex<double>, dmn_4<nu, nu, r_dmn_t, w> >& GS_r_w);

      template<class walker_type,class H_type>
      void accumulate(walker_type&  walker,
                      H_type&       H_interactions);

      void compute(function<std::complex<double>, dmn_4<nu, nu, r_dmn_t, w> >& G_r_w,
                   function<std::complex<double>, dmn_4<nu, nu, r_dmn_t, w> >& GS_r_w);

      void finalize();

    private:

      template<class walker_type, class H_type>
      double  compute_U_times_n (walker_type&  walker,
                                 H_type&              H_interactions,
                                 double               t_start,
                                 int                  flavor);

    private:

      parameters_type&          parameters;
      concurrency_type&         concurrency;

      int                       N_spin_orbitals;


      cached_delayed_nfft_1D<double, nu_nu_r_DCA>   cached_nfft_1D_G_obj;
      cached_delayed_nfft_1D<double, nu_nu_r_DCA>   cached_nfft_1D_GS_obj;
    };

    template<class parameters_type, class base_cluster_type>
    MC_single_particle_accumulator<SS_CT_HYB, NFFT, parameters_type, base_cluster_type>::MC_single_particle_accumulator(parameters_type&          parameters_ref):
      parameters(parameters_ref),
      concurrency(parameters.get_concurrency()),

      N_spin_orbitals(b::dmn_size()*s::dmn_size()),

      cached_nfft_1D_G_obj (parameters.get_number_of_positive_frequencies()),
      cached_nfft_1D_GS_obj(parameters.get_number_of_positive_frequencies())
    {}

    template<class parameters_type, class base_cluster_type>
    MC_single_particle_accumulator<SS_CT_HYB, NFFT, parameters_type, base_cluster_type>::~MC_single_particle_accumulator()
    {}

    template<class parameters_type, class base_cluster_type>
    void MC_single_particle_accumulator<SS_CT_HYB, NFFT, parameters_type, base_cluster_type>::initialize(function<std::complex<double>, dmn_4<nu, nu, r_dmn_t, w> >& G_r_w,
                                                                                                              function<std::complex<double>, dmn_4<nu, nu, r_dmn_t, w> >& GS_r_w)
    {
      cached_nfft_1D_G_obj .initialize();
      cached_nfft_1D_GS_obj.initialize();

      G_r_w = 0;
      GS_r_w = 0;
    }

    template<class parameters_type, class base_cluster_type>
    void MC_single_particle_accumulator<SS_CT_HYB, NFFT, parameters_type, base_cluster_type>::finalize()
    {}

    template<class parameters_type, class base_cluster_type>
    template<class walker_type, class H_type>
    void MC_single_particle_accumulator<SS_CT_HYB, NFFT, parameters_type, base_cluster_type>::accumulate(walker_type&  walker,
                                                                                                              H_type&       H_interactions)
    {
      typedef typename walker_type::vertex_vertex_matrix_type  vertex_vertex_matrix_type;
      typedef typename walker_type::configuration_type::orbital_configuration_type orbital_configuration_type;

      static int* coor = new int[2];
      static nu nu_obj;
      static int coor_nfft[5];
      static scalar_type BETA = parameters.get_beta();
      static scalar_type one_div_two_beta = 1./(2.*BETA);

      int sign = walker.get_sign();
      double U_times_n;
      double t_i, t_j;
      for(int flavor=0; flavor<N_spin_orbitals; flavor++){
        nu_obj.linind_2_subind(flavor, coor);
        coor_nfft[0] = coor[0];
        coor_nfft[1] = coor[1];
        coor_nfft[2] = coor[0];
        coor_nfft[3] = coor[1];
        coor_nfft[4] = 0;

        orbital_configuration_type& segments = walker.get_configuration().get_vertices(flavor);
        vertex_vertex_matrix_type&  M_ind    = walker.get_M_matrices()(flavor);

        for(int j=0; j<(int)segments.size(); j++){
          t_j = segments[j].t_start();
          U_times_n = compute_U_times_n(walker, H_interactions, t_j, flavor);
          for(int i=0; i<(int)segments.size(); i++){
            t_i = segments[i].t_end();;

            double scaled_tau = (t_i-t_j)*one_div_two_beta;

            cached_nfft_1D_G_obj .accumulate_at(coor_nfft, scaled_tau, M_ind(j,i)*sign);
            cached_nfft_1D_GS_obj.accumulate_at(coor_nfft, scaled_tau, U_times_n*M_ind(j,i)*sign);
          }
        }

      }
    }

    template<class parameters_type, class base_cluster_type>
    template<class walker_type, class H_type>
    double MC_single_particle_accumulator<SS_CT_HYB, NFFT, parameters_type, base_cluster_type>::compute_U_times_n(walker_type&  walker,
                                                                                                                       H_type&              H_interactions,
                                                                                                                       double               t_start,
                                                                                                                       int                  flavor)
    {
      typedef typename walker_type::configuration_type::orbital_configuration_type orbital_configuration_type;
      double U_times_n = 0;

      for(int j=0;j<N_spin_orbitals;j++){
        if(j == flavor)
          continue;

        if(walker.get_configuration().get_full_line(j)){
          U_times_n += 1./2.*(H_interactions(j,flavor,0)+H_interactions(flavor,j,0));
        }
        else
          {
            orbital_configuration_type& vertices_j = walker.get_configuration().get_vertices(j);
            for(int y = 0; y < int(vertices_j.size()); y++){
              if(vertices_j[y].t_start() < vertices_j[y].t_end()){
                if(vertices_j[y].t_start() <= t_start && t_start <= vertices_j[y].t_end())
                  U_times_n += 1./2.*(H_interactions(j,flavor,0)+H_interactions(flavor,j,0));
              }
              else {
                if((vertices_j[y].t_start() <= t_start || t_start <= vertices_j[y].t_end()))
                  U_times_n += 1./2.*(H_interactions(j,flavor,0)+H_interactions(flavor,j,0));
              }
            }
          }
      }

      return U_times_n;
    }


    template<class parameters_type, class base_cluster_type>
    void MC_single_particle_accumulator<SS_CT_HYB, NFFT, parameters_type, base_cluster_type>::compute(function<std::complex<double>, dmn_4<nu, nu, r_dmn_t, w> >& G_r_w,
                                                                                                           function<std::complex<double>, dmn_4<nu, nu, r_dmn_t, w> >& GS_r_w)
    {
      cached_nfft_1D_G_obj.finalize(G_r_w);
      cached_nfft_1D_GS_obj.finalize(GS_r_w);
    }

  } // namespace QMC

}

#endif
