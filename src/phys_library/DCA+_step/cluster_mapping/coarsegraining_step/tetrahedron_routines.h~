//-*-C++-*-

#ifndef DCA_TETRAHEDRON_INTEGRATION_ROUTINES_H
#define DCA_TETRAHEDRON_INTEGRATION_ROUTINES_H

namespace DCA
{

  class tetrahedron_integration_routines
  {
  public:

    // 1D
    template<typename scalartype>
    static void execute(int size, scalartype volume, scalartype* H_0, scalartype* H_1, scalartype* f_result);

    // 2D
    template<typename scalartype>
    static void execute(int size, scalartype volume, std::complex<scalartype>* H_0, std::complex<scalartype>* H_1, std::complex<scalartype>* H_2, std::complex<scalartype>* f_result);

    // 3D
    template<typename scalartype>
    static void execute(int size, scalartype volume, scalartype* H_0, scalartype* H_1, scalartype* H_2, scalartype* H_3, scalartype* f_result);

  private:

    template<typename scalartype>
    static scalartype integrate_matrix_element_2D(scalartype* f, scalartype* e);

    template<typename scalartype>
    static eigenvalue_degeneracy_t find_degeneracy_2D(scalartype* f, scalartype* e);

    template<typename scalartype>
    static bool pair_same(std::pair<complex<scalartype>, complex<scalartype> > const& x,
                          std::pair<complex<scalartype>, complex<scalartype> > const& y);

  };

  /************************************
   ***
   ***   2D tetrahedron-integration
   ***
   ************************************/

  template<typename scalartype>
  void tetrahedron_integration_routines::execute(int N, scalartype volume,
                                                 std::complex<scalartype>* G_0,
                                                 std::complex<scalartype>* G_1,
                                                 std::complex<scalartype>* G_2,
                                                 std::complex<scalartype>* f_result)
  {
    std::complex<scalartype> G_inv_0[N*N]; std::complex<scalartype> VR_0[N*N]; std::complex<scalartype> VR_inv_0[N*N]; std::complex<scalartype> W_0[N];
    std::complex<scalartype> G_inv_1[N*N]; std::complex<scalartype> VR_1[N*N]; std::complex<scalartype> VR_inv_1[N*N]; std::complex<scalartype> W_1[N];
    std::complex<scalartype> G_inv_2[N*N]; std::complex<scalartype> VR_2[N*N]; std::complex<scalartype> VR_inv_2[N*N]; std::complex<scalartype> W_2[N];

    {
      memcpy(G_inv_0, G_0, sizeof(std::complex<scalartype>)*N*N);
      memcpy(G_inv_1, G_1, sizeof(std::complex<scalartype>)*N*N);
      memcpy(G_inv_2, G_2, sizeof(std::complex<scalartype>)*N*N);

      LIN_ALG::GEINV<LIN_ALG::CPU>::execute(N, G_inv_0); assert(LIN_ALG::GEINV<LIN_ALG::CPU>::execute(G_0, G_inv_0));
      LIN_ALG::GEINV<LIN_ALG::CPU>::execute(N, G_inv_1); assert(LIN_ALG::GEINV<LIN_ALG::CPU>::execute(G_1, G_inv_1));
      LIN_ALG::GEINV<LIN_ALG::CPU>::execute(N, G_inv_2); assert(LIN_ALG::GEINV<LIN_ALG::CPU>::execute(G_2, G_inv_2));
    }

    {
      int INFO  = -1;
      int LWORK = 16*std::max(1,2*N-1);

      scalartype               RWORK[std::max(1, 3*N-2)];
      std::complex<scalartype>  WORK[LWORK];

      LIN_ALG::GEEV<LIN_ALG::CPU>::execute('N', 'V', N, G_inv_0, N, W_0, VR_inv_0, N, VR_0, N, WORK, LWORK, RWORK, INFO);
      LIN_ALG::GEEV<LIN_ALG::CPU>::execute('N', 'V', N, G_inv_1, N, W_1, VR_inv_1, N, VR_1, N, WORK, LWORK, RWORK, INFO);
      LIN_ALG::GEEV<LIN_ALG::CPU>::execute('N', 'V', N, G_inv_2, N, W_2, VR_inv_2, N, VR_2, N, WORK, LWORK, RWORK, INFO);
    }

    {
      memcpy(VR_inv_0, VR_0, sizeof(std::complex<scalartype>)*N*N);
      memcpy(VR_inv_1, VR_1, sizeof(std::complex<scalartype>)*N*N);
      memcpy(VR_inv_2, VR_2, sizeof(std::complex<scalartype>)*N*N);

      LIN_ALG::GEINV<LIN_ALG::CPU>::execute(N, VR_inv_0); assert(LIN_ALG::GEINV<LIN_ALG::CPU>::execute(VR_0, G_inv_0));
      LIN_ALG::GEINV<LIN_ALG::CPU>::execute(N, VR_inv_1); assert(LIN_ALG::GEINV<LIN_ALG::CPU>::execute(VR_1, VR_inv_0));
      LIN_ALG::GEINV<LIN_ALG::CPU>::execute(N, VR_inv_2); assert(LIN_ALG::GEINV<LIN_ALG::CPU>::execute(VR_2, VR_inv_0));
    }

    std::complex<scalartype> eigenvalues[3];
    std::complex<scalartype> matrix_elements[3];

    for(int l=0; l<N*N; l++)
      f_result[l] = 0;

    for(int i=0; i<N; i++){
      for(int j=0; j<N; j++){

        for(int l=0; l<N; l++){

          matrix_elements[0] = VR_inv_0[i+l*N]*VR_0[l+j*N];
          matrix_elements[1] = VR_inv_1[i+l*N]*VR_1[l+j*N];
          matrix_elements[2] = VR_inv_2[i+l*N]*VR_2[l+j*N];

          eigenvalues[0] = W_0[l];
          eigenvalues[1] = W_1[l];
          eigenvalues[2] = W_2[l];

          f_result[i + j*N] += integrate_matrix_element_2D(matrix_elements, eigenvalues);
        }
      }
    }

    for(int i=0; i<N; i++)
      for(int j=0; j<N; j++)
        f_result[i + j*N] *= (2.*volume);
  }

  template<typename scalartype>
  scalartype tetrahedron_integration_routines::integrate_matrix_element_2D(scalartype* f, scalartype* e)
  {
    scalartype r[2+1];

    eigenvalue_degeneracy_t degeneracy = find_degeneracy_2D(f, e);

    switch(degeneracy)
      {
      case NO_DEGENERACY:
        {
          r[0] = (-(e[0]*(e[1] - e[2])*(-2.*e[1]*e[2] + e[0]*(e[1] + e[2]))*std::log(-e[0])) + e[0]*(e[1] - e[2])*(-2.*e[1]*e[2] + e[0]*(e[1] + e[2]))*std::log(-e[1]) + (e[0] - e[1])*(e[0]*(e[0] - e[2])*(e[1] - e[2]) + (e[0] - e[1])*std::pow(e[2],2)*std::log(e[1]) + (-e[0] + e[1])*std::pow(e[2],2)*std::log(e[2])))/(2.*std::pow(e[0] - e[1],2)*std::pow(e[0] - e[2],2)*(e[1] - e[2]));
          r[1] = -(-(std::pow(e[0],2)*std::pow(e[1] - e[2],2)*std::log(-e[0])) + std::pow(e[0],2)*std::pow(e[1] - e[2],2)*std::log(-e[1]) + (e[0] - e[1])*(e[1]*(e[0] - e[2])*(e[1] - e[2]) + (-e[0] + e[1])*std::pow(e[2],2)*std::log(e[1]) + (e[0] - e[1])*std::pow(e[2],2)*std::log(e[2])))/(2.*std::pow(e[0] - e[1],2)*(e[0] - e[2])*std::pow(e[1] - e[2],2));
          r[2] = -(-(std::pow(e[0],2)*std::pow(e[1] - e[2],2)*std::log(-e[0])) + std::pow(e[0],2)*std::pow(e[1] - e[2],2)*std::log(-e[1]) + (e[0] - e[1])*e[2]*((e[0] - e[2])*(-e[1] + e[2]) + (2.*e[0]*e[1] - e[0]*e[2] - e[1]*e[2])*std::log(e[1]) + (-2.*e[0]*e[1] + e[0]*e[2] + e[1]*e[2])*std::log(e[2])))/(2.*(e[0] - e[1])*std::pow(e[0] - e[2],2)*std::pow(e[1] - e[2],2));
        }
        break;

      case TWOFOLD_DEGENERACY:
        {
          r[0] = (std::pow(e[0],2) - std::pow(e[1],2) - 2.*e[0]*e[1]*std::log(-e[0]) + 2.*e[0]*e[1]*std::log(-e[1]))/(2.*std::pow(e[0] - e[1],3));
          r[1] = -(3.*std::pow(e[0],2) - 4.*e[0]*e[1] + std::pow(e[1],2) - 2.*std::pow(e[0],2)*std::log(-e[0]) + 2.*std::pow(e[0],2)*std::log(-e[1]))/(4.*std::pow(e[0] - e[1],3));
          r[2] = -(3.*std::pow(e[0],2) - 4.*e[0]*e[1] + std::pow(e[1],2) - 2.*std::pow(e[0],2)*std::log(-e[0]) + 2.*std::pow(e[0],2)*std::log(-e[1]))/(4.*std::pow(e[0] - e[1],3));
        }
        break;

      case THREEFOLD_DEGENERACY:
        r[0] = 1./6.*1./e[0];
        r[1] = 1./6.*1./e[0];
        r[2] = 1./6.*1./e[0];
        break;

      default:
        throw std::logic_error(__FUNCTION__);
      }

    assert(f[0]*r[0]+f[1]*r[1]+f[2]*r[2] == f[0]*r[0]+f[1]*r[1]+f[2]*r[2]);

    return f[0]*r[0]+f[1]*r[1]+f[2]*r[2];
  }

  template<typename scalartype>
  eigenvalue_degeneracy_t tetrahedron_integration_routines::find_degeneracy_2D(scalartype* f, scalartype* e)
  {
    std::vector<std::pair<scalartype, scalartype> > vec(3);

    vec[0].first = e[0]; vec[0].second = f[0];
    vec[1].first = e[1]; vec[1].second = f[1];
    vec[2].first = e[2]; vec[2].second = f[2];

    stable_sort(vec.begin(), vec.end(), &pair_less);
    int degeneracy = unique(vec.begin(), vec.end(), tetrahedron_integration_routines::pair_same)-vec.begin();

    e[0] = vec[0].first; f[0] = vec[0].second;
    e[1] = vec[1].first; f[1] = vec[1].second;
    e[2] = vec[2].first; f[2] = vec[2].second;

    if(degeneracy == 3)
      return NO_DEGENERACY;

    if(degeneracy == 2)
      return TWOFOLD_DEGENERACY;

    if(degeneracy == 1)
      return THREEFOLD_DEGENERACY;

    throw std::logic_error(__FUNCTION__);
    return NO_DEGENERACY;
  }

  template<typename scalartype>
  bool tetrahedron_integration_routines::pair_same(std::pair<complex<scalartype>, complex<scalartype> > const& x,
                                                   std::pair<complex<scalartype>, complex<scalartype> > const& y)
  {
    scalartype abs_x = abs(x.first);
    scalartype abs_y = abs(y.first);

    if(abs_x < 1. && abs_y < 1.)
      {
	return abs(x.first-y.first)<1.e-6;
      }
    else
      {
        scalartype MAX = abs_x>abs_y? abs_x:abs_y;
        return abs(x.first-y.first)<((1.e-6)*MAX);
      }
  }

}

#endif
