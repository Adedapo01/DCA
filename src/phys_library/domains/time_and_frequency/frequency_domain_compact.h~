//-*-C++-*-

#ifndef FREQUENCY_DOMAIN_COMPACT_H
#define FREQUENCY_DOMAIN_COMPACT_H

enum vertex_frequency_representation {COMPACT, EXTENDED, COMPACT_POSITIVE, EXTENDED_POSITIVE, COMPACT_SORTED, EXTENDED_SORTED, 
				      EXTENDED_BOSONIC, EXTENDED_FERMIONIC, CORE_SORTED, HIGH_FREQUENCY_SORTED};

typedef vertex_frequency_representation vertex_frequency_representation_type;

std::string to_str(vertex_frequency_representation NAME)
{
  switch(NAME)
    {
    case COMPACT:
      return "COMPACT";
      break;

    case EXTENDED: 
      return "EXTENDED";
      break;

    case COMPACT_POSITIVE:
      return "COMPACT_POSITIVE";
      break;

    case EXTENDED_POSITIVE:
      return "EXTENDED_POSITIVE";
      break;

    case EXTENDED_BOSONIC:
      return "EXTENDED_BOSONIC";
      break;

    default:
      throw std::logic_error(__FUNCTION__);
    }

  return "NONE";
}

/*!
 * \class  vertex_frequency_domain
 *
 * \author Peter Staar
 * 
 * \brief  This class implements various types and orderings of the matsubara-frequency domain, via a templates.
 */
template<vertex_frequency_representation_type vfr_t>
class vertex_frequency_domain
{
public:

  typedef double element_type;

public:

  static int&                 get_size();
  static std::string          get_name();
  static std::vector<double>& get_elements();

  static std::vector<int>&    get_corresponding_frequency_domain_index();
  
  template<IO::FORMAT DATA_FORMAT>
  static void write(IO::writer<DATA_FORMAT>& writer);

  template<class stream_type>
  static void to_JSN(stream_type& ss);

  template<typename parameters_t>
  static void initialize(parameters_t& parameters);
};

template<vertex_frequency_representation_type vfr_t>
int& vertex_frequency_domain<vfr_t>::get_size()
{
  static int size;
  return size;
}

template<vertex_frequency_representation_type vfr_t>
std::string vertex_frequency_domain<vfr_t>::get_name()
{
  static std::string name = "vertex-frequency-domain (" + to_str(vfr_t) + ")";
  return name;
}

template<vertex_frequency_representation_type vfr_t>
std::vector<double>& vertex_frequency_domain<vfr_t>::get_elements()
{
  static std::vector<double> elements;
  return elements;
}

template< vertex_frequency_representation_type vfr_t>
std::vector<int>& vertex_frequency_domain<vfr_t>::get_corresponding_frequency_domain_index()
{
  static std::vector<int> elements;
  return elements;
}

template<vertex_frequency_representation_type vfr_t>
template<IO::FORMAT DATA_FORMAT>
void vertex_frequency_domain<vfr_t>::write(IO::writer<DATA_FORMAT>& writer)
{
  writer.open_group(get_name());

  writer.execute("elements", get_elements());

  writer.close_group();
}

template<vertex_frequency_representation_type vfr_t>
template<class stream_type>
void vertex_frequency_domain<vfr_t>::to_JSN(stream_type& ss)
{
  switch(vfr_t)
    {
    case EXTENDED:
      ss << "\"extended_vertex_frequency_domain\" : [\n";
      break;
    case COMPACT:
      ss << "\"compact_vertex_frequency_domain\" : [\n";
      break;

    case EXTENDED_POSITIVE:
      ss << "\"extended_positive_vertex_frequency_domain\" : [\n";
      break;
    case COMPACT_POSITIVE:
      ss << "\"compact_positive_vertex_frequency_domain\" : [\n";
      break;

    case COMPACT_SORTED:
      ss << "\"compact_sorted_vertex_frequency_domain\" : [\n";
      break;
    case EXTENDED_SORTED:
      ss << "\"extended_sorted_vertex_frequency_domain\" : [\n";
      break;

    case EXTENDED_BOSONIC:
      ss << "\"extended_bosonic_vertex_frequency_domain\" : [\n";
      break;
    case EXTENDED_FERMIONIC:
      ss << "\"extended_fermionic_vertex_frequency_domain\" : [\n";
      break;
    case CORE_SORTED:
      ss << "\"core_sorted_vertex_frequency_domain\" : [\n";
      break;
    case HIGH_FREQUENCY_SORTED:
      ss << "\"high_frequency_sorted_vertex_frequency_domain\" : [\n";
      break;

    default:
      throw std::logic_error(__FUNCTION__);
    }
    
  for(int i=0; i<get_size(); i++)
    if(i == get_size()-1)
      ss << get_elements()[i] << "\n";
    else
      ss << get_elements()[i] << ",\n";
  
  ss << "]\n";
}

template<>
template<typename parameters_t>
void vertex_frequency_domain<COMPACT>::initialize(parameters_t& parameters)
{
  get_size() = 2*parameters.get_tp_fermionic_frequencies();//wn_c();

  get_elements().resize(get_size());

  for(int l=0; l<parameters.get_tp_fermionic_frequencies(); l++)
    {
      get_elements()[get_size()/2  +l] =  M_PI/parameters.get_beta()*(1+2*l);
      get_elements()[get_size()/2-1-l] = -M_PI/parameters.get_beta()*(1+2*l);
    }

  get_corresponding_frequency_domain_index().resize(get_size(),-1);

  std::vector<double>& wn = frequency_domain::get_elements();

  for(int i=0; i<get_size(); i++)
    for(size_t j=0; j<wn.size(); j++)
      if(fabs(wn[j]-get_elements()[i])<1.e-6)
	get_corresponding_frequency_domain_index()[i] = j;

  for(int i=0; i<get_size(); i++)
    if(get_corresponding_frequency_domain_index()[i] == -1 ||
       fabs(wn[get_corresponding_frequency_domain_index()[i]]-get_elements()[i])>1.e-6)
      throw std::logic_error(__FUNCTION__);
}

template<>
template<typename parameters_t>
void vertex_frequency_domain<COMPACT_POSITIVE>::initialize(parameters_t& parameters)
{
  get_size() = parameters.get_tp_fermionic_frequencies();//wn_c();

  get_elements().resize(get_size());

  for(int l=0; l<parameters.get_tp_fermionic_frequencies(); l++)
    get_elements()[l] =  M_PI/parameters.get_beta()*(1+2*l);

  get_corresponding_frequency_domain_index().resize(get_size(),-1);

  std::vector<double>& wn = frequency_domain::get_elements();

  for(int i=0; i<get_size(); i++)
    for(size_t j=0; j<wn.size(); j++)
      if(fabs(wn[j]-get_elements()[i])<1.e-6)
	get_corresponding_frequency_domain_index()[i] = j;

  for(int i=0; i<get_size(); i++)
    if(get_corresponding_frequency_domain_index()[i] == -1||
       fabs(wn[get_corresponding_frequency_domain_index()[i]]-get_elements()[i])>1.e-6)
      throw std::logic_error(__FUNCTION__);

  assert(get_elements().back() == vertex_frequency_domain<COMPACT>::get_elements().back());
}

template<>
template<typename parameters_t>
void vertex_frequency_domain<EXTENDED>::initialize(parameters_t& parameters)
{
  get_size() = 2*(parameters.get_tp_fermionic_frequencies() + abs(parameters.get_w_channel()));

  get_elements().resize(get_size());

  for(int l=0; l<get_size()/2; l++)
    {
      get_elements()[get_size()/2  +l] =  M_PI/parameters.get_beta()*(1+2*l);
      get_elements()[get_size()/2-1-l] = -M_PI/parameters.get_beta()*(1+2*l);
    }

  get_corresponding_frequency_domain_index().resize(get_size(),-1);

  std::vector<double>& wn = frequency_domain::get_elements();

  for(int i=0; i<get_size(); i++)
    for(size_t j=0; j<wn.size(); j++)
      if(fabs(wn[j]-get_elements()[i])<1.e-6)
	get_corresponding_frequency_domain_index()[i] = j;

  for(int i=0; i<get_size(); i++)
    if(get_corresponding_frequency_domain_index()[i] == -1 ||
       fabs(wn[get_corresponding_frequency_domain_index()[i]]-get_elements()[i])>1.e-6)
      throw std::logic_error(__FUNCTION__);
}

template<>
template<typename parameters_t>
void vertex_frequency_domain<EXTENDED_POSITIVE>::initialize(parameters_t& parameters)
{
  get_size() = parameters.get_tp_fermionic_frequencies() + abs(parameters.get_w_channel());

  get_elements().resize(get_size());

  for(int l=0; l<get_size(); l++)
    get_elements()[l] =  M_PI/parameters.get_beta()*(1+2*l);

  get_corresponding_frequency_domain_index().resize(get_size(),-1);

  std::vector<double>& wn = frequency_domain::get_elements();

  for(int i=0; i<get_size(); i++)
    for(size_t j=0; j<wn.size(); j++)
      if(fabs(wn[j]-get_elements()[i])<1.e-6)
	get_corresponding_frequency_domain_index()[i] = j;

  for(int i=0; i<get_size(); i++)
    if(get_corresponding_frequency_domain_index()[i] == -1 ||
       fabs(wn[get_corresponding_frequency_domain_index()[i]]-get_elements()[i])>1.e-6)
      throw std::logic_error(__FUNCTION__);

  assert(get_elements().back() == vertex_frequency_domain<EXTENDED>::get_elements().back());
}










/*
template<>
template<typename parameters_t>
void vertex_frequency_domain<COMPACT_SORTED>::initialize(parameters_t& parameters)
{
  get_size() = 2*(parameters.get_wn_c() + parameters.get_N_Delta());

  get_elements().resize(get_size());

  for(int l=0; l<parameters.get_wn_c(); l++)
    {
      get_elements()[2*l+0] =  M_PI/parameters.get_beta()*(1+2*l);
      get_elements()[2*l+1] = -M_PI/parameters.get_beta()*(1+2*l);
    }

  for(int l=0; l<parameters.get_N_Delta(); l++)
    {
      get_elements()[2*parameters.get_wn_c() + 2*l+0] =  M_PI/parameters.get_beta()*(1+2*parameters.get_wn_c() + 2*parameters.get_Delta_wn()*l);
      get_elements()[2*parameters.get_wn_c() + 2*l+1] = -M_PI/parameters.get_beta()*(1+2*parameters.get_wn_c() + 2*parameters.get_Delta_wn()*l);
    }

  get_corresponding_frequency_domain_index().resize(get_size(),-1);

  std::vector<double>& wn = frequency_domain::get_elements();

  for(int i=0; i<get_size(); i++)
    for(size_t j=0; j<wn.size(); j++)
      if(fabs(wn[j]-get_elements()[i])<1.e-6)
	get_corresponding_frequency_domain_index()[i] = j;

  for(int i=0; i<get_size(); i++)
    if(get_corresponding_frequency_domain_index()[i] == -1 ||
       fabs(wn[get_corresponding_frequency_domain_index()[i]]-get_elements()[i])>1.e-6)
      throw std::logic_error(__FUNCTION__);
}

template<>
template<typename parameters_t>
void vertex_frequency_domain<EXTENDED_SORTED>::initialize(parameters_t& parameters)
{
  get_size() = 2*(parameters.get_wn_c());

  if(parameters.get_N_Delta() > 0)
    get_size() += 2*(1 + (parameters.get_N_Delta()-1)*parameters.get_Delta_wn());

  get_elements().resize(get_size());

  for(int l=0; l<get_size()/2; l++)
    {
      get_elements()[2*l+0] =  M_PI/parameters.get_beta()*(1+2*l);
      get_elements()[2*l+1] = -M_PI/parameters.get_beta()*(1+2*l);
    }

  get_corresponding_frequency_domain_index().resize(get_size(),-1);

  std::vector<double>& wn = frequency_domain::get_elements();

  for(int i=0; i<get_size(); i++)
    for(size_t j=0; j<wn.size(); j++)
      if(fabs(wn[j]-get_elements()[i])<1.e-6)
	get_corresponding_frequency_domain_index()[i] = j;

  for(int i=0; i<get_size(); i++)
    if(get_corresponding_frequency_domain_index()[i] == -1)
      throw std::logic_error(__FUNCTION__);
}
*/

template<>
template<typename parameters_t>
void vertex_frequency_domain<EXTENDED_BOSONIC>::initialize(parameters_t& parameters)
{
  get_size() = 2*parameters.get_sp_bosonic_frequencies()+1;
  
  get_elements().resize(get_size(), -2.*M_PI/parameters.get_beta()*int(get_size()/2));
  
  for(int l=0; l<get_size(); l++){
    get_elements()[l] += l*2.*M_PI/parameters.get_beta();
    //cout << get_elements()[l] << endl;
  }
}

/*
template<>
template<typename parameters_t>
void vertex_frequency_domain<EXTENDED_FERMIONIC>::initialize(parameters_t& parameters)
{
//   get_size() = 2*(parameters.get_wn_c());

//   if(parameters.get_N_Delta() > 0)
//     get_size() += 2*(1 + (parameters.get_N_Delta()-1)*parameters.get_Delta_wn());

  get_elements().resize(get_size());

  for(int l=0; l<get_size()/2; l++)
    {
      get_elements()[get_size()/2  +l] =  M_PI/parameters.get_beta()*(1+2*l);
      get_elements()[get_size()/2-1-l] = -M_PI/parameters.get_beta()*(1+2*l);
    }
}

template<>
template<typename parameters_t>
void vertex_frequency_domain<CORE_SORTED>::initialize(parameters_t& parameters)
{
  get_size() = 2*(parameters.get_wn_c());

  get_elements().resize(get_size());

  for(int l=0; l<get_size()/2; l++)
    {
      get_elements()[2*l+0] =  M_PI/parameters.get_beta()*(1+2*l);
      get_elements()[2*l+1] = -M_PI/parameters.get_beta()*(1+2*l);
    }

  get_corresponding_frequency_domain_index().resize(get_size(),-1);

  std::vector<double>& wn = frequency_domain::get_elements();

  for(int i=0; i<get_size(); i++)
    for(size_t j=0; j<wn.size(); j++)
      if(fabs(wn[j]-get_elements()[i])<1.e-6)
	get_corresponding_frequency_domain_index()[i] = j;

  for(int i=0; i<get_size(); i++)
    if(get_corresponding_frequency_domain_index()[i] == -1)
      throw std::logic_error(__FUNCTION__);
}

template<>
template<typename parameters_t>
void vertex_frequency_domain<HIGH_FREQUENCY_SORTED>::initialize(parameters_t& parameters)
{
  get_size() = 0;//2*(parameters.get_wn_c());

  if(parameters.get_N_Delta() > 0)
    get_size() += 2*(1 + (parameters.get_N_Delta()-1)*parameters.get_Delta_wn());

  get_elements().resize(get_size());

  for(int l=0; l<get_size()/2; l++)
    {
      get_elements()[2*l+0get_size()/2+l]   =  M_PI/parameters.get_beta()*(1+2*(l+parameters.get_wn_c()));
      get_elements()[2*l+1get_size()/2-1-l] = -M_PI/parameters.get_beta()*(1+2*(l+parameters.get_wn_c()));
    }

  get_corresponding_frequency_domain_index().resize(get_size(),-1);

  std::vector<double>& wn = frequency_domain::get_elements();

  for(int i=0; i<get_size(); i++)
    for(size_t j=0; j<wn.size(); j++)
      if(fabs(wn[j]-get_elements()[i])<1.e-6)
	get_corresponding_frequency_domain_index()[i] = j;

  for(int i=0; i<get_size(); i++)
    if(get_corresponding_frequency_domain_index()[i] == -1)
      throw std::logic_error(__FUNCTION__);
}
*/

#endif


/*
template<>
template<typename parameters_t>
void vertex_frequency_domain<COMPACT>::initialize(parameters_t& parameters)
{
  get_size() = 2*(parameters.get_wn_c() + parameters.get_N_Delta());

  get_elements().resize(get_size());

  for(int l=0; l<parameters.get_wn_c(); l++)
    {
      get_elements()[get_size()/2  +l] =  M_PI/parameters.get_beta()*(1+2*l);
      get_elements()[get_size()/2-1-l] = -M_PI/parameters.get_beta()*(1+2*l);
    }

  for(int l=0; l<parameters.get_N_Delta(); l++)
    {
      get_elements()[get_size()/2+parameters.get_wn_c()  +l] =  M_PI/parameters.get_beta()*(1+2*parameters.get_wn_c() + 2*parameters.get_Delta_wn()*l);
      get_elements()[get_size()/2-parameters.get_wn_c()-1-l] = -M_PI/parameters.get_beta()*(1+2*parameters.get_wn_c() + 2*parameters.get_Delta_wn()*l);
    }

  get_corresponding_frequency_domain_index().resize(get_size(),-1);

  std::vector<double>& wn = frequency_domain::get_elements();

  for(int i=0; i<get_size(); i++)
    for(size_t j=0; j<wn.size(); j++)
      if(fabs(wn[j]-get_elements()[i])<1.e-6)
	get_corresponding_frequency_domain_index()[i] = j;

  for(int i=0; i<get_size(); i++)
    if(get_corresponding_frequency_domain_index()[i] == -1 ||
       fabs(wn[get_corresponding_frequency_domain_index()[i]]-get_elements()[i])>1.e-6)
      throw std::logic_error(__FUNCTION__);
}

template<>
template<typename parameters_t>
void vertex_frequency_domain<EXTENDED>::initialize(parameters_t& parameters)
{
  get_size() = 2*(parameters.get_wn_c());

  if(parameters.get_N_Delta() > 0)
    get_size() += 2*(1 + (parameters.get_N_Delta()-1)*parameters.get_Delta_wn());

  get_elements().resize(get_size());

  for(int l=0; l<get_size()/2; l++)
    {
      get_elements()[get_size()/2  +l] =  M_PI/parameters.get_beta()*(1+2*l);
      get_elements()[get_size()/2-1-l] = -M_PI/parameters.get_beta()*(1+2*l);
    }

//   assert(get_elements()[0] == vertex_frequency_domain<COMPACT>::get_elements()[0]);
}

template<>
template<typename parameters_t>
void vertex_frequency_domain<COMPACT_POSITIVE>::initialize(parameters_t& parameters)
{
  get_size() = (parameters.get_wn_c() + parameters.get_N_Delta());

  get_elements().resize(get_size());

  for(int l=0; l<parameters.get_wn_c(); l++)
    get_elements()[l] =  M_PI/parameters.get_beta()*(1+2*l);

  for(int l=0; l<parameters.get_N_Delta(); l++)
    get_elements()[parameters.get_wn_c()+l] = M_PI/parameters.get_beta()*(1+2*parameters.get_wn_c() + 2*parameters.get_Delta_wn()*l);

  get_corresponding_frequency_domain_index().resize(get_size(),-1);

  std::vector<double>& wn = frequency_domain::get_elements();

  for(int i=0; i<get_size(); i++)
    for(size_t j=0; j<wn.size(); j++)
      if(fabs(wn[j]-get_elements()[i])<1.e-6)
	get_corresponding_frequency_domain_index()[i] = j;

  for(int i=0; i<get_size(); i++)
    if(get_corresponding_frequency_domain_index()[i] == -1||
       fabs(wn[get_corresponding_frequency_domain_index()[i]]-get_elements()[i])>1.e-6)
      throw std::logic_error(__FUNCTION__);
}

template<>
template<typename parameters_t>
void vertex_frequency_domain<EXTENDED_POSITIVE>::initialize(parameters_t& parameters)
{
  get_size() = (parameters.get_wn_c());

  if(parameters.get_N_Delta() > 0)
    get_size() += (1 + (parameters.get_N_Delta()-1)*parameters.get_Delta_wn());

  get_elements().resize(get_size());

  for(int l=0; l<get_size(); l++){
    get_elements()[l] =  M_PI/parameters.get_beta()*(1+2*l);
    //cout << get_elements()[l] << endl;
  }

  assert(get_elements().back() == vertex_frequency_domain<COMPACT_POSITIVE>::get_elements().back());
}
 */
