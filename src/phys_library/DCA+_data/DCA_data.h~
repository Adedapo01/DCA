//-*-C++-*-

#ifndef DCA_DATA_H
#define DCA_DATA_H

namespace DCA
{
  /*!
   * \class   DCA_data
   *
   * \brief   class that contains all functions needed for the DCA-MOMS
   *
   * \date    21 December, 2009
   * \author  Peter Staar
   * \version 1.0
   */
  template<class parameters_type>
  class DCA_data
  {
#include "type_definitions.h"

    const static int DIMENSION = lattice_type::DIMENSION;

    typedef typename parameters_type::profiler_type    profiler_t;
    typedef typename parameters_type::concurrency_type concurrency_type;

  public:

    typedef b b_dmn_t;
    typedef s s_dmn_t;

    typedef r_DCA r_dmn_t;
    typedef k_DCA k_dmn_t;

    typedef typename r_dmn_t::parameter_type r_cluster_type;
    typedef typename k_dmn_t::parameter_type k_cluster_type;

  public:

    DCA_data(parameters_type& parameters_ref);
    ~DCA_data();

    void read(std::string filename);

    void write(std::string filename);

    template<IO::FORMAT DATA_FORMAT>
    void read(IO::reader<DATA_FORMAT>& reader);

    template<IO::FORMAT DATA_FORMAT>
    void write(IO::writer<DATA_FORMAT>& reader);

    void initialize();

    void initialize_H_0_and_H_i();

    void initialize_coarsegraining();

    void initialize_G0();

    bool test_initialize_G0();

    void initialize_Sigma();

    void initialize_functions(bool read_sigma_file=true);

    void compute_Sigma_bands();
    void compute_single_particle_properties();

    void coarsegrain_functions(int DCA_iteration);

    void compute_Sigma_cg();
    void print_Sigma_QMC_versus_Sigma_cg();

    void compute_G_k_w();

    void compute_G0_k_w_cluster_excluded();
    void compute_G0_r_w_cluster_excluded_by_definition();

    void compute_G0_k_t_cluster_excluded_from_G0_k_w_cluster_excluded();
    void compute_G0_r_t_cluster_excluded_from_G0_k_t_cluster_excluded();

    void compute_G0_r_t_cluster_excluded_from_G0_r_w_cluster_excluded();
    void compute_G0_k_w_cluster_excluded_from_G0_r_w_cluster_excluded();

    void compute_G_r_w_from_M_r_w_by_definition(function<std::complex<double>, dmn_4<nu,nu,r_dmn_t,w> >& M_r_w);
    void compute_Sigma_r_w_by_definition();

    void   compute_orbital_occupancy();
    double compute_density();

    void   adjust_chemical_potential();
    double integrate_to_Fermi_energy();

    //void   diagonolize_H();

    void initialize_coarsegrainingB();

  private:

    void initialize_orbital_occupancy();

    void initialize_H_LDA();
    void initialize_H_LDA(string filename);

    void compute_G0_k_w();
    void compute_G0_k_t();

  private:

    parameters_type& parameters;
    concurrency_type& concurrency;

    double      energy_shift;

  public:

    coarsegrain          <parameters_type,       k_cluster_type,          QUADRATURE_INTEGRATION> coarsegrain_obj;
    coarsegrain_inversion<parameters_type, dmn_0<k_cluster_type>, k_HOST, QUADRATURE_INTEGRATION> coarsegrain_inversion_obj;

    DCA::coarsegraining_sp<parameters_type, k_DCA> coarsegrain_obj_2;

    function<int                 , nu_nu>                 H_symmetry;
    function<double              , dmn_3<nu,nu,r_dmn_t> > H_interactions;

    function<std::complex<double>, dmn_3<nu,nu,k_dmn_t> > H_DCA;
    function<std::complex<double>, dmn_3<nu,nu,k_HOST> >  H_HOST;
    function<std::complex<double>, dmn_3<nu,nu,k_LDA> >   H_LDA;

    function<double              , r_HOST>   phi_r;

    function<double              , nu_k_cut> band_structure;

    function<std::complex<double>, nu_k_cut> Sigma_band_structure;

    function<std::complex<double>, nu_k_cut> Sigma_cluster_band_structure;
    function<std::complex<double>, nu_k_cut> Sigma_lattice_band_structure;

    function<std::complex<double>, nu_k_cut> Sigma_band_structure_interpolated;
    function<std::complex<double>, nu_k_cut> Sigma_band_structure_coarsegrained;

    function<std::complex<double>, dmn_3<nu,nu,k_HOST> > G_k;//("Greens-k-lattice");
    function<std::complex<double>, dmn_3<nu,nu,k_HOST> > S_k;//("Sigma-k-lattice");
    function<std::complex<double>, dmn_3<nu,nu,r_HOST> > S_r;//("Sigma-r-lattice");


    //   function<             double , dmn_3<nu,nu, k_HOST> > Z_k;
    //   function<std::complex<double>, dmn_3<nu,nu, k_HOST> > DOS_surface;
    //   function<std::complex<double>, dmn_3<nu,nu, k_HOST> > Fermi_surface;

    //function<double , dmn_2<nu, k_HOST> > n_k;
    //function<double , dmn_2<nu, k_HOST> > grad_n_k;

    function<std::complex<double>, dmn_4<nu,nu,k_dmn_t,w> > Sigma;

    function<std::complex<double>, dmn_4<nu,nu,k_dmn_t,w> > Sigma_cluster;
    function<std::complex<double>, dmn_4<nu,nu,k_HOST ,w> > Sigma_lattice;
    function<std::complex<double>, dmn_4<nu,nu,k_HOST ,w> > Sigma_lattice_interpolated;
    function<std::complex<double>, dmn_4<nu,nu,k_HOST ,w> > Sigma_lattice_coarsegrained;

    function<std::complex<double>, dmn_4<nu,nu,k_dmn_t,w> > G_k_w;
    function<double              , dmn_4<nu,nu,k_dmn_t,t> > G_k_t;
    function<std::complex<double>, dmn_4<nu,nu,r_dmn_t,w> > G_r_w;
    function<double              , dmn_4<nu,nu,r_dmn_t,t> > G_r_t;

    function<std::complex<double>, dmn_4<nu,nu,k_dmn_t,w> > G0_k_w;
    function<double              , dmn_4<nu,nu,k_dmn_t,t> > G0_k_t;
    function<std::complex<double>, dmn_4<nu,nu,r_dmn_t,w> > G0_r_w;
    function<double              , dmn_4<nu,nu,r_dmn_t,t> > G0_r_t;

    function<std::complex<double>, dmn_4<nu,nu,k_dmn_t,w> > G0_k_w_cluster_excluded;
    function<double              , dmn_4<nu,nu,k_dmn_t,t> > G0_k_t_cluster_excluded;
    function<std::complex<double>, dmn_4<nu,nu,r_dmn_t,w> > G0_r_w_cluster_excluded;
    function<double              , dmn_4<nu,nu,r_dmn_t,t> > G0_r_t_cluster_excluded;

    function<std::complex<double>, dmn_8<b,b,b,b,k_dmn_t,k_dmn_t,w_VERTEX,w_VERTEX> > G4_k_k_w_w;

    function<double              , dmn_4<nu,nu,r_dmn_t,t> > K_r_t;

    // function<int   , diagram_order_domain_type> visited_expansion_order_k;

    function<double, nu>                        orbital_occupancy;
    // function<double, DCA_iteration_domain_type> mu;
  };

  template<class parameters_type>
  DCA_data<parameters_type>::DCA_data(parameters_type& parameters_ref):

    parameters(parameters_ref),
    concurrency(parameters.get_concurrency()),

    coarsegrain_obj          (parameters),
    coarsegrain_inversion_obj(parameters),//, H_HOST),
    //coarsegrain_inversion_obj(parameters, H_HOST),

    coarsegrain_obj_2(parameters),

    H_symmetry("H_symmetry"),
    H_interactions("interaction-matrix"),

    H_DCA("H_DCA"),
    H_HOST("H_HOST"),
    H_LDA("H_LDA"),

    phi_r("phi-r"),
    band_structure("band-structure"),

    Sigma_band_structure        ("Sigma-band-structure"),

    Sigma_cluster_band_structure("Sigma-cluster-band-structure"),
    Sigma_lattice_band_structure("Sigma-lattice-band-structure"),

    Sigma_band_structure_interpolated("Sigma-band-structure-interpolated"),
    Sigma_band_structure_coarsegrained("Sigma-band-structure-coarsegrained"),

    G_k("Greens-k-lattice"),
    S_k("Sigma-k-lattice"),
    S_r("Sigma-r-lattice"),

    //   Z_k("Z_k"),
    //   DOS_surface("DOS_surface"),
    //   Fermi_surface("Fermi_surface"),

    Sigma("Self_Energy"),

    Sigma_cluster("Self-Energy-cluster"),
    Sigma_lattice("Self-energy-lattice"),

    Sigma_lattice_interpolated("Sigma_lattice_interpolated"),
    Sigma_lattice_coarsegrained("Sigma_lattice_coarsegrained"),

    G_k_w("cluster_greens_function_G_k_w"),
    G_k_t("cluster_greens_function_G_k_t"),
    G_r_w("cluster_greens_function_G_r_w"),
    G_r_t("cluster_greens_function_G_r_t"),

    G0_k_w("free_cluster_greens_function_G0_k_w"),
    G0_k_t("free_cluster_greens_function_G0_k_t"),
    G0_r_w("free_cluster_greens_function_G0_r_w"),
    G0_r_t("free_cluster_greens_function_G0_r_t"),

    G0_k_w_cluster_excluded("cluster_excluded_greens_function_G0_k_w"),
    G0_k_t_cluster_excluded("cluster_excluded_greens_function_G0_k_t"),
    G0_r_w_cluster_excluded("cluster_excluded_greens_function_G0_r_w"),
    G0_r_t_cluster_excluded("cluster_excluded_greens_function_G0_r_t"),

    G4_k_k_w_w("G4_k_k_w_w"),

    K_r_t("K_r_t"),

    //visited_expansion_order_k("<k>"),

    orbital_occupancy("orbital_occupancy")//,

    //mu("chemical_potential_mu")
  {
    H_symmetry = -1;
  }

  template<class parameters_type>
  DCA_data<parameters_type>::~DCA_data()
  {}

  template<class parameters_type>
  void DCA_data<parameters_type>::read(std::string filename)
  {
    if(concurrency.id()==0)
      cout << "\n\n\t starts reading \n\n";

    if(concurrency.id()==concurrency.first())
      {
        IO::FORMAT FORMAT = parameters.get_output_format();

        switch(FORMAT)
          {
          case IO::JSON :
            {
              IO::reader<IO::JSON> reader;

              reader.open_file(filename);

              this->read(reader);

              reader.close_file();
            }
            break;

          case IO::HDF5 :
            {
              IO::reader<IO::HDF5> reader;

              reader.open_file(filename);

              this->read(reader);

              reader.close_file();
            }
            break;

          default:
            throw std::logic_error(__FUNCTION__);
          }
      }

    concurrency.broadcast(parameters.get_chemical_potential());

    concurrency.broadcast_object(Sigma);

    if(parameters.get_vertex_measurement_type() != NONE)
      {
        concurrency.broadcast_object(G_k_w);
        concurrency.broadcast_object(G4_k_k_w_w);
      }
  }

  template<class parameters_type>
  template<IO::FORMAT DATA_FORMAT>
  void DCA_data<parameters_type>::read(IO::reader<DATA_FORMAT>& reader)
  {
    {
      reader.open_group("functions");

      reader.execute(Sigma);

      if(parameters.get_vertex_measurement_type() != NONE)
        {
          reader.execute(G_k_w);

          reader.execute(G4_k_k_w_w);
        }

      reader.close_group();
    }

    {
      reader.open_group("parameters");
      reader.open_group("physics-parameters");

      reader.execute("chemical-potential", parameters.get_chemical_potential());

      reader.close_group();
      reader.close_group();
    }
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::write(std::string file_name)
  {
    IO::FORMAT  FORMAT    = parameters.get_output_format();

    cout << "\n\n\t\t start writing " << file_name << "\n\n";

    switch(FORMAT)
      {
      case IO::JSON :
        {
          IO::writer<IO::JSON> writer;
          {
            writer.open_file(file_name);

            parameters.write(writer);
            this->     write(writer);

            writer.close_file();
          }
        }
        break;

      case IO::HDF5 :
        {
          IO::writer<IO::HDF5> writer;
          {
            writer.open_file(file_name);

            parameters.write(writer);
            this->     write(writer);

            writer.close_file();
          }
        }
        break;

      default:
        throw std::logic_error(__FUNCTION__);
      }
  }

  template<class parameters_type>
  template<IO::FORMAT DATA_FORMAT>
  void DCA_data<parameters_type>::write(IO::writer<DATA_FORMAT>& writer)
  {
    writer.open_group("functions");

    writer.execute(band_structure);

    if(parameters.use_interpolated_Self_energy())
      {
        writer.execute(Sigma_band_structure);
        writer.execute(Sigma_cluster_band_structure);
        writer.execute(Sigma_lattice_band_structure);
        writer.execute(Sigma_band_structure_interpolated);
        writer.execute(Sigma_band_structure_coarsegrained);

        //compute_single_particle_properties();

        writer.execute(S_k);
        writer.execute(S_r);

        writer.execute(G_k);
      }

    writer.execute(Sigma);

    //   writer.execute(Sigma_lattice);
    //   writer.execute(Sigma_lattice_interpolated);

    if(parameters.get_vertex_measurement_type() != NONE)
      {
        writer.execute(G_k_w);

        writer.execute(G4_k_k_w_w);
      }

    writer.close_group();
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::initialize()
  {
    initialize_H_0_and_H_i();

    initialize_coarsegraining();

    initialize_G0();

    initialize_Sigma();
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::initialize_H_0_and_H_i()
  {
    if(concurrency.id()==0)
      cout << "\n\n\t initialize H_0(k) and H_i \n\n";

    model::initialize_H_LDA(H_LDA, parameters);

    model::initialize_H_interaction(H_interactions, parameters);

    model::initialize_H_symmetries(H_symmetry);

    {
      wannier_interpolation<k_LDA, k_dmn_t>::execute(H_LDA, H_DCA);
      wannier_interpolation<k_LDA, k_HOST >::execute(H_LDA, H_HOST);

      compute_band_structure::execute(parameters, H_LDA, band_structure);

      //coarsegrain_obj_2.plot_H_q(H_HOST);
    }
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::initialize_coarsegraining()
  {
    if(concurrency.id()==0)
      cout << "\n\n\t initialize coarsegraining\n\n";

    assert(log2(parameters.get_number_of_periods())+1 <= parameters.get_k_mesh_refinement());

    int min_rec = 1;
    if(parameters.get_number_of_periods()>0)
      min_rec = log2(parameters.get_number_of_periods())+1;

    int rec  = std::max(min_rec, parameters.get_k_mesh_refinement());
    int quad =                   parameters.get_gaussian_quadrature_rule();

    coarsegrain_obj.reset(rec, quad);

    cout.precision(6);
    coarsegrain_obj.print_domain();

    coarsegrain_obj_2.compute_phi_r(phi_r);
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::initialize_G0()
  {
    profiler_t prof("initialize-G0", "input", __LINE__);

    if(concurrency.id()==0)
      cout << "\n\n\t initialize G0\n\n";

    {
      function<std::complex<double>, nu_nu_k_HOST_w> Sigma_zero;
      Sigma_zero = 0.;

      coarsegrain_obj_2.compute_G_K_w(H_HOST, Sigma_zero, G0_k_w);

      symmetrize::execute(G0_k_w, H_symmetry, true);
    }

    {
      coarsegrain_obj_2.compute_G0_K_t(H_HOST, G0_k_t);

      symmetrize::execute(G0_k_t, H_symmetry, true);
    }

    assert(test_initialize_G0());

    {
      MATH_ALGORITHMS::TRANSFORM<k_dmn_t, r_dmn_t>::execute(G0_k_w, G0_r_w);
      MATH_ALGORITHMS::TRANSFORM<k_dmn_t, r_dmn_t>::execute(G0_k_t, G0_r_t);

      symmetrize::execute(G0_r_w, H_symmetry, true);
      symmetrize::execute(G0_r_t, H_symmetry, true);
    }
  }

  template<class parameters_type>
  bool DCA_data<parameters_type>::test_initialize_G0()
  {
    if(concurrency.id()==0)
      {
        /*
          cout << "\n\n\t start testing MATH-ALGORTHMS\n\n";

          function<std::complex<double>, dmn_4<nu,nu,k_dmn_t,w> > G0_k_w_test("G_k_w_test");
          function<             double , dmn_4<nu,nu,k_dmn_t,t> > G0_k_t_test("G_k_t_test");

          {
          G0_k_w_test = G0_k_w;

          MATH_ALGORITHMS::TRANSFORM<w, t>::execute(G0_k_w_test, G0_k_t_test);

          SHOW::execute(G0_k_t, G0_k_t_test);
          }

          {
          G0_k_t_test = G0_k_t;

          MATH_ALGORITHMS::TRANSFORM<t, w>::execute(G0_k_t_test, G0_k_w_test);

          SHOW::execute(G0_k_w, G0_k_w_test);
          }

          cout << "\n\n\t stop testing MATH-ALGORTHMS\n\n";
        */
      }

    return true;
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::initialize_Sigma()
  {
    profiler_t prof("initialize-Sigma", "input", __LINE__);

    if(parameters.get_Sigma_file() != "zero")
      {
        this->read(parameters.get_Sigma_file());

        if(parameters.use_interpolated_Self_energy())
          {
            coarsegrain_inversion_obj.execute(Sigma, Sigma_lattice_interpolated, Sigma_lattice_coarsegrained, Sigma_lattice);

            symmetrize::execute(Sigma_lattice);
            symmetrize::execute(Sigma_lattice_coarsegrained);

            concurrency << "\n\n \t--> inverted Sigma_{QMC} \n\n";

            coarsegrain_obj_2.compute_S_K_w(Sigma_lattice, Sigma_cluster);

            print_Sigma_QMC_versus_Sigma_cg();

            coarsegrain_obj_2.plot_S_q(Sigma_lattice);
          }

      }

  }

  template<class parameters_type>
  void DCA_data<parameters_type>::compute_single_particle_properties()
  {
    {
      memcpy(&S_k(0), &Sigma_lattice(0,0,0,w::dmn_size()/2), sizeof(std::complex<double>)*std::pow(2*b::dmn_size(),2.)*k_HOST::dmn_size());

      MATH_ALGORITHMS::TRANSFORM<k_HOST, r_HOST>::execute(S_k, S_r);
    }

    {
      int w_ind=w::dmn_size()/2;

      LIN_ALG::matrix<std::complex<double>, LIN_ALG::CPU> I_k  ("I_matrix", nu::dmn_size());
      LIN_ALG::matrix<std::complex<double>, LIN_ALG::CPU> G_inv("G_inv"   , nu::dmn_size());

      std::complex<double> i_wm_plus_mu;

      real(i_wm_plus_mu) = parameters.get_chemical_potential();
      imag(i_wm_plus_mu) = w::get_elements()[w_ind];

      for(int i=0; i<nu::dmn_size(); i++)
        I_k(i,i) = i_wm_plus_mu;

      for(int k_ind=0; k_ind<k_HOST::dmn_size(); k_ind++){

        {
          for(int j=0; j<nu::dmn_size(); j++)
            for(int i=0; i<nu::dmn_size(); i++)
              G_inv(i,j) = I_k(i,j)-H_HOST(i,j,k_ind);

          LIN_ALG::GEINV<LIN_ALG::CPU>::execute_on_Green_function_matrix(G_inv);

          for(int j=0; j<nu::dmn_size(); j++)
            for(int i=0; i<nu::dmn_size(); i++)
              G0_k_w(i,j,k_ind,w_ind) = G_inv(i,j);
        }

        {
          for(int j=0; j<nu::dmn_size(); j++)
            for(int i=0; i<nu::dmn_size(); i++)
              G_inv(i,j) = I_k(i,j)-H_HOST(i,j,k_ind)-Sigma_lattice(i,j,k_ind,w_ind);

          LIN_ALG::GEINV<LIN_ALG::CPU>::execute_on_Green_function_matrix(G_inv);

          for(int j=0; j<nu::dmn_size(); j++)
            for(int i=0; i<nu::dmn_size(); i++)
              G_k(i,j,k_ind) = G_inv(i,j);
        }
      }
    }
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::compute_Sigma_bands()
  {
    {
      if(parameters.use_interpolated_Self_energy())
        compute_Sigma_cg();

      Sigma_band_structure        .reset();
      Sigma_cluster_band_structure.reset();

      std::vector<std::pair<double, int> > length_and_distance(k_dmn_t::dmn_size(), std::pair<double, int>(0,-1));

      for(int k_ind=0; k_ind<k_domain_cut_dmn_type::dmn_size(); ++k_ind){

        //std::vector<double> k_vec = k_cluster_type::back_inside_cluster(k_domain_cut_dmn_type::get_elements()[k_ind]);
        std::vector<double> k_vec = cluster_operations::translate_inside_cluster(k_domain_cut_dmn_type::get_elements()[k_ind],
                                                                                 k_cluster_type::get_super_basis_vectors());

        for(int K_ind=0; K_ind<k_dmn_t::dmn_size(); ++K_ind){
          length_and_distance[K_ind].second = K_ind;
          //length_and_distance[K_ind].first  = k_cluster_type::find_minimal_distance(k_vec, k_dmn_t::get_elements()[K_ind]);
          length_and_distance[K_ind].first  = cluster_operations::minimal_distance(k_vec, k_dmn_t::get_elements()[K_ind],
                                                                                   k_cluster_type::get_super_basis_vectors());
        }

        std::sort(length_and_distance.begin(), length_and_distance.end());

        int result_ind = length_and_distance[0].second;

        for(int nu_ind=0; nu_ind<2*b::dmn_size(); ++nu_ind){
          Sigma_band_structure        (nu_ind, k_ind) = Sigma        (nu_ind, nu_ind, result_ind, w::dmn_size()/2);
          Sigma_cluster_band_structure(nu_ind, k_ind) = Sigma_cluster(nu_ind, nu_ind, result_ind, w::dmn_size()/2);
        }
      }
    }

    Sigma_lattice_band_structure.reset();
    if(parameters.use_interpolated_Self_energy())
      {
        function<std::complex<double>, dmn_2<nu,k_HOST> > S_k_dmn("S_k_dmn_s");

        for(int b_ind=0; b_ind<b::dmn_size(); ++b_ind)
          for(int s_ind=0; s_ind<s::dmn_size(); ++s_ind)
            for(int k_ind=0; k_ind<k_HOST::dmn_size(); ++k_ind)
              S_k_dmn(b_ind, s_ind, k_ind) = Sigma_lattice(b_ind, s_ind, b_ind, s_ind, k_ind, w::dmn_size()/2);

        hspline_interpolation<k_HOST, k_domain_cut_dmn_type>::execute(S_k_dmn, Sigma_lattice_band_structure, -1./2.);
      }

    Sigma_band_structure_interpolated.reset();
    if(true)
      {
        function<std::complex<double>, dmn_2<nu,k_HOST> > S_k_dmn("S_k_dmn_s");

        coarsegrain_inversion_obj.interpolate(Sigma, Sigma_lattice_interpolated);
        symmetrize::execute(Sigma_lattice_interpolated);

        for(int b_ind=0; b_ind<b::dmn_size(); ++b_ind)
          for(int s_ind=0; s_ind<s::dmn_size(); ++s_ind)
            for(int k_ind=0; k_ind<k_HOST::dmn_size(); ++k_ind)
              S_k_dmn(b_ind, s_ind, k_ind) = Sigma_lattice_interpolated(b_ind, s_ind, b_ind, s_ind, k_ind, w::dmn_size()/2);

        hspline_interpolation<k_HOST, k_domain_cut_dmn_type>::execute(S_k_dmn, Sigma_band_structure_interpolated, -1./2.);
      }

    Sigma_band_structure_coarsegrained.reset();
    if(parameters.use_interpolated_Self_energy())
      {
        function<std::complex<double>, dmn_2<nu,k_HOST> > S_k_dmn("S_k_dmn_s");

        for(int b_ind=0; b_ind<b::dmn_size(); ++b_ind)
          for(int s_ind=0; s_ind<s::dmn_size(); ++s_ind)
            for(int k_ind=0; k_ind<k_HOST::dmn_size(); ++k_ind)
              S_k_dmn(b_ind, s_ind, k_ind) = Sigma_lattice_coarsegrained(b_ind, s_ind, b_ind, s_ind, k_ind, w::dmn_size()/2);

        hspline_interpolation<k_HOST, k_domain_cut_dmn_type>::execute(S_k_dmn, Sigma_band_structure_coarsegrained, -1./2.);
      }
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::coarsegrain_functions(int DCA_iteration)
  {
    //   if(parameters.use_interpolated_Self_energy() && DCA_iteration==0 && parameters.get_Sigma_file() != "zero"){

    //     coarsegrain_inversion_obj.execute(Sigma, Sigma_lattice_interpolated, Sigma_lattice_coarsegrained, Sigma_lattice);

    //     symmetrize::execute(Sigma_lattice);
    //     symmetrize::execute(Sigma_lattice_coarsegrained);

    //     concurrency << "\n\n \t--> inverted Sigma_{QMC} \n\n";
    //   }

    compute_G_k_w();

    if(parameters.adjust_chemical_potential())
      adjust_chemical_potential();

    {
      if(DCA_iteration > 0 || parameters.get_Sigma_file() != "zero")
        compute_G0_k_w_cluster_excluded();
      else
        G0_k_w_cluster_excluded = G_k_w;

      compute_G0_k_t_cluster_excluded_from_G0_k_w_cluster_excluded();
      compute_G0_r_t_cluster_excluded_from_G0_k_t_cluster_excluded();
    }

    compute_orbital_occupancy();
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::compute_G0_k_w_cluster_excluded()
  {
    compute_Sigma_cg();

    symmetrize::execute(G_k_w, H_symmetry);

    DCA::transform_to<DCA::G0_K_W_CLUSTER_EXCLUDED>::execute(G_k_w, Sigma_cluster, G0_k_w_cluster_excluded);

    symmetrize::execute(G0_k_w_cluster_excluded, H_symmetry);
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::compute_G0_k_w()
  {
    function<std::complex<double>, dmn_4<nu,nu,k_dmn_t,w> > Sigma_zero;
    Sigma_zero = 0.;

    //coarsegrain_obj.compute_G_from_H_and_Sigma(H_LDA, Sigma_zero, G0_k_w);
    coarsegrain_obj_2.compute_G_k_w(H_HOST, Sigma_zero, G0_k_w);

    symmetrize::execute(G0_k_w, H_symmetry, true);
  }

  /*
    template<class parameters_type>
    void DCA_data<parameters_type>::compute_G0_k_t()
    {
    {
    coarsegrain_obj.compute_G0_k_t_from_H(H_LDA, G0_k_t);
    SHOW::execute(G0_k_t);

    symmetrize::execute(G0_k_t, H_symmetry, true);
    }

    {
    coarsegrain_obj_2.compute_G0_K_t(H_HOST, G0_k_t);
    SHOW::execute(G0_k_t);

    symmetrize::execute(G0_k_t, H_symmetry, true);
    }

    throw std::logic_error(__FUNCTION__);
    }
  */

  template<class parameters_type>
  void DCA_data<parameters_type>::compute_G_k_w()
  {
    /*
      int min_rec = 1;
      if(parameters.get_number_of_periods()>0)
      min_rec = log2(parameters.get_number_of_periods())+1;

      function<std::complex<double>, dmn_4<nu,nu,k_dmn_t,w> > G_k_w_prev;

      double maximum=0;
      for(int rec=min_rec; rec<=parameters.get_k_mesh_refinement(); rec++){
      for(int quad=1; quad<=parameters.get_gaussian_quadrature_rule(); quad++){

      coarsegrain_obj.reset(rec, quad);

      if(parameters.use_interpolated_Self_energy())
      coarsegrain_obj.compute_G_from_H_and_continuous_Sigma(H_LDA, Sigma_lattice, G_k_w);
      else
      coarsegrain_obj.compute_G_from_H_and_Sigma(H_LDA, Sigma, G_k_w);

      maximum=0;
      for(int i=0; i<G_k_w.size(); ++i)
      maximum = std::max(maximum,  abs(G_k_w_prev(i) - G_k_w(i)));

      //       if(concurrency.id()==concurrency.first())
      //  cout << "\t\t" << rec << "\t" << quad << "\t" << maximum << "\t" << parameters.get_integration_accuracy() << "\n";

      if(maximum < parameters.get_integration_accuracy())
      break;
      else
      G_k_w_prev = G_k_w;
      }
      if(maximum < parameters.get_integration_accuracy())
      break;
      }
    */

    if(parameters.use_interpolated_Self_energy())
      {
        //coarsegrain_obj.compute_G_from_H_and_continuous_Sigma(H_LDA, Sigma_lattice, G_k_w);
        coarsegrain_obj_2.compute_G_K_w(H_HOST, Sigma_lattice, G_k_w);
      }
    else
      {
        coarsegrain_obj.compute_G_from_H_and_Sigma(H_LDA, Sigma, G_k_w);

        coarsegrain_obj_2.compute_G_K_w(H_HOST, Sigma, G_k_w);
      }

    symmetrize::execute(G_k_w, H_symmetry);
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::compute_Sigma_cg()
  {
    /*
      if(parameters.use_interpolated_Self_energy())
      {
      int min_rec = 1;
      if(parameters.get_number_of_periods()>0)
      min_rec = log2(parameters.get_number_of_periods())+1;

      function<std::complex<double>, dmn_4<nu,nu,k_dmn_t,w> > Sigma_cluster_prev;

      double maximum=0;
      for(int rec=min_rec; rec<=parameters.get_k_mesh_refinement(); rec++){
      for(int quad=1; quad<=parameters.get_gaussian_quadrature_rule(); quad++){

      coarsegrain_obj.reset(rec, quad);

      coarsegrain_obj.coarsegrain_continuous_Sigma(Sigma_lattice, Sigma_cluster);

      maximum=0;
      for(int i=0; i<Sigma_cluster.size(); ++i)
      maximum = std::max(maximum,  abs(Sigma_cluster_prev(i) - Sigma_cluster(i)));

      //    if(concurrency.id()==concurrency.first())
      //      cout << "\t\t" << rec << "\t" << quad << "\t" << maximum << "\t" << parameters.get_integration_accuracy() << "\n";

      if(maximum < parameters.get_integration_accuracy())
      break;
      else
      Sigma_cluster_prev = Sigma_cluster;
      }
      if(maximum < parameters.get_integration_accuracy())
      break;
      }
      }
      else
      Sigma_cluster = Sigma;
    */

    if(parameters.use_interpolated_Self_energy())
      {
        //coarsegrain_obj.coarsegrain_continuous_Sigma(Sigma_lattice, Sigma_cluster);
        coarsegrain_obj_2.compute_S_K_w(Sigma_lattice, Sigma_cluster);
      }
    else
      Sigma_cluster = Sigma;

    print_Sigma_QMC_versus_Sigma_cg();

    symmetrize::execute(Sigma_cluster, H_symmetry);
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::print_Sigma_QMC_versus_Sigma_cg()
  {
    if(concurrency.id()==0 and parameters.use_interpolated_Self_energy())
      {
        if(DIMENSION==2){
          cout << "\n\n";
          cout << "        K-vectors           || Re[Sigma_QMC]   Im[Sigma_QMC]   Re[Sigma_cg]    Im[Sigma_cg] \n";
          cout << "--------------------------------------------------------------------------------------------\n";
        }

        if(DIMENSION==3){
          cout << "\n\n";
          cout << "                K-vectors                      || Re[Sigma_QMC]   Im[Sigma_QMC]   Re[Sigma_cg]    Im[Sigma_cg] \n";
          cout << "---------------------------------------------------------------------------------------------------------------\n";
        }

        for(int k_ind=0; k_ind<k_dmn_t::dmn_size(); ++k_ind){
          VECTOR_OPERATIONS::PRINT(k_dmn_t::get_elements()[k_ind]);
          cout << real(Sigma        (0,0,k_ind,w::dmn_size()/2)) << "\t" << imag(Sigma        (0,0,k_ind,w::dmn_size()/2)) << "\t";
          cout << real(Sigma_cluster(0,0,k_ind,w::dmn_size()/2)) << "\t" << imag(Sigma_cluster(0,0,k_ind,w::dmn_size()/2)) << "\n";
        }
        cout << "\n\n";
      }
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::compute_G0_k_t_cluster_excluded_from_G0_k_w_cluster_excluded()
  {
    G0_k_w_cluster_excluded -= G0_k_w;

    FT<w, t>::execute(G0_k_w_cluster_excluded, G0_k_t_cluster_excluded);

    G0_k_t_cluster_excluded += G0_k_t;

    G0_k_w_cluster_excluded += G0_k_w;
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::compute_G0_r_t_cluster_excluded_from_G0_r_w_cluster_excluded()
  {
    G0_r_w_cluster_excluded -= G0_r_w;

    FT<w, t>::execute(G0_r_w_cluster_excluded, G0_r_t_cluster_excluded);

    G0_r_t_cluster_excluded += G0_r_t;

    G0_r_w_cluster_excluded += G0_r_w;
  }

  /*
    template<class parameters_type>
    void DCA_data<parameters_type>::compute_G0_k_w_cluster_excluded_from_G0_r_w_cluster_excluded()
    {
    FT<r_dmn_t, k_dmn_t>::execute(G0_r_w_cluster_excluded, G0_k_w_cluster_excluded);
    symmetrize::execute(G0_k_w_cluster_excluded, H_symmetry, true);
    }
  */

  template<class parameters_type>
  void DCA_data<parameters_type>::compute_G0_r_t_cluster_excluded_from_G0_k_t_cluster_excluded()
  {
    //FT<k_dmn_t, r_dmn_t>::execute(G0_k_t_cluster_excluded, G0_r_t_cluster_excluded);

    MATH_ALGORITHMS::TRANSFORM<k_dmn_t, r_dmn_t>::execute(G0_k_t_cluster_excluded, G0_r_t_cluster_excluded);

    symmetrize::execute(G0_r_t_cluster_excluded, H_symmetry, true);
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::adjust_chemical_potential()
  {
    concurrency << "\n\n\t   --> adjust_chemical_potential : ";

    const static double DELTA   = 0.5;
    const static double EPSILON = 1.e-3;

    double d_0  = parameters.get_density();
    double mu_0 = parameters.get_chemical_potential();

    double n_0 = compute_density();

    if(fabs(d_0-n_0)>EPSILON)
      {
        double mu_1, n_1;

        mu_1 = n_0 > d_0 ? mu_0-DELTA : mu_0+DELTA;
        parameters.get_chemical_potential() = mu_1;

        n_1 = compute_density();

        while(fabs(d_0-n_1)>EPSILON)
          {
            double mu_new = (mu_0-mu_1)/(n_0-n_1)*(d_0-n_1) + mu_1;

            parameters.get_chemical_potential() = mu_new;

            n_0 = n_1;
            mu_0 = mu_1;

            n_1 = compute_density();
            mu_1 = mu_new;
          }

        n_0 = n_1;
      }

    concurrency << parameters.get_chemical_potential();
    concurrency << "\t(";
    concurrency << n_0;
    concurrency << ")\n";
  }

  template<class parameters_type>
  double DCA_data<parameters_type>::compute_density()
  {
    compute_G_k_w();

    compute_orbital_occupancy();

    double density = 0;
    for(int nu_ind=0; nu_ind<b::dmn_size()*s::dmn_size(); nu_ind++)
      density += orbital_occupancy(nu_ind);

    /*
      cout << compute_density::execute(parameters, *this, concurrency)
      << " <---> "
      << density
      << " <===> "
      << compute_density::execute(parameters,*this);
    */

    return density;
  }

  template<class parameters_type>
  void DCA_data<parameters_type>::compute_orbital_occupancy()
  {
    // cout << __FUNCTION__ << endl;

    static int r0_index = r_cluster_type::origin_index();

    G_k_w -= G0_k_w;

    for(int i=0; i<G_k_t.size(); i++)
      G_k_t(i) = 0;

    FT<w, t>::execute(G_k_w, G_k_t);

    /*
      {
      cout << "\n\n\t start testing MATH-ALGORTHMS\n\n";
      function<std::complex<double>, nu_nu_k_PCM_w> G_k_PCM_w("G_k_PCM_w");
      function<             double , nu_nu_k_PCM_t> G_k_PCM_t("G_k_PCM_t");
      for(int l=0; l<G_k_PCM_w.size(); l++)
      G_k_PCM_w(l) = G_k_w(l);
      MATH_ALGORITHMS::TRANSFORM<w, t>::execute(G_k_PCM_w, G_k_PCM_t);
      for(int l=0; l<G_k_PCM_t.size(); l++)
      if(abs(G_k_PCM_t(l) - G_k_t(l))>1.e-6)
      cout << "\t" << l << "\t" << G_k_PCM_t(l) << "\t" << G_k_t(l) << "\t" << abs(G_k_PCM_t(l) - G_k_t(l)) << endl;
      cout << "\n\n\t stop testing MATH-ALGORTHMS\n\n";
      }
    */

    G_k_t += G0_k_t;

    //FT<k_dmn_t, r_dmn_t>::execute(G_k_t, G_r_t);
    MATH_ALGORITHMS::TRANSFORM<k_dmn_t, r_dmn_t>::execute(G_k_t, G_r_t);

    G_k_w += G0_k_w; // reset G0_k_w_cluster_excluded to original value !!

    for(int nu_ind=0; nu_ind<b::dmn_size()*s::dmn_size(); nu_ind++){
      orbital_occupancy(nu_ind) = (1.-G_r_t(nu_ind, nu_ind, r0_index, 0));
    }
  }

}

#endif











