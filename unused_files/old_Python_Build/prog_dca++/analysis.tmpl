//-*-C++-*-

/*
________  _________     _____                                             
\______ \ \_   ___ \   /  _  \      .__                                   
 |    |  \/    \  \/  /  /_\  \   __|  |___                               
 |    `   \     \____/    |    \ /__    __/                               
/_______  /\______  /\____|__  /    |__|                                  
        \/        \/         \/                                           

__________        __                   _________ __                       
\______   \ _____/  |_  ___________   /   _____//  |______  _____ _______ 
 |     ___// __ \   __\/ __ \_  __ \  \_____  \\   __\__  \ \__  \\_  __ \
 |    |   \  ___/|  | \  ___/|  | \/  /        \|  |  / __ \_/ __ \|  | \/
 |____|    \___  >__|  \___  >__|    /_______  /|__| (____  (____  /__|   
               \/          \/                \/           \/     \/       
_________________________ ___   __________            .__       .__       
\_   _____/\__    ___/   |   \  \____    /__ _________|__| ____ |  |__    
 |    __)_   |    | /    ~    \   /     /|  |  \_  __ \  |/ ___\|  |  \   
 |        \  |    | \    Y    /  /     /_|  |  /|  | \/  \  \___|   Y  \  
/_______  /  |____|  \___|_  /  /_______ \____/ |__|  |__|\___  >___|  /  
        \/                 \/           \/                    \/     \/   
 */

#include "compiler_directives.h"

#include "include_files.h"

std::string get_version()
{
  string str("DEFAULT");
  return str;
}

void print_version()
{
  string str = get_version();
 
  cout << "\n\n\n";
  cout << "*************************************************************************************\n";
  cout << "***                                  VERSION                                      ***\n";
  cout << "*************************************************************************************\n";
  cout << "\n\n\n";
 
  cout << str << endl;
}

bool file_exists(std::string file_name)
{
  std::wifstream tmp(file_name.c_str());

  if(!tmp or !tmp.good() or tmp.bad())
    {
      return false;
    }
  else
    {
      return true;
    }
}

//void synchronize_devices(){}

int main(int argc,char *argv[])
{
  if (argc < 2) {
    std::cout << "Usage: "<<argv[0]<<" inputFileName\n";
    return -1;
  }

  std::string file_name(argv[1]);

  //============================================================ Configure the calculation by selecting type definitions.


  //static const LIN_ALG ::device_type                   LIN_ALG_DEVICE               = LIN_ALG::CPU;
  static const DCA     ::CLUSTER_SOLVER_NAMES          CLUSTER_SOLVER_NAME          = DCA::CT_AUX_CLUSTER_SOLVER;
  static const COMP_LIB::PARALLELIZATION_LIBRARY_NAMES PARALLELIZATION_LIBRARY_NAME = COMP_LIB::MPI_LIBRARY;

  typedef COMP_LIB::parallelization<PARALLELIZATION_LIBRARY_NAME>  concurrency_type;
  typedef Parameters<concurrency_type, model, CLUSTER_SOLVER_NAME> parameters_type;

  //typedef MultiOrbitalMultiSiteStructure<parameters_type>          MOMS_type;
  typedef DCA::DCA_data<parameters_type>          MOMS_type;

  //====================================================================== Create the algorithms and parameters object from the input file

  concurrency_type concurrency(argc, argv);

  concurrency << "DCA main: starting (MPI-world set up).\n\n";

  std::string stamp = get_version();
  if(concurrency.id() == concurrency.first()){
    print_version();
    //provenance<interaction_type, model, MC_ALGORITHM_TYPE, MPI_LIBRARY_TYPE>::print_on_shell(QMC_INTEGRATOR_BIT);
  }

  parameters_type parameters(get_version(), concurrency);

  parameters.read_input_and_broadcast(file_name);

  parameters.update_model();
  parameters.update_domains();

  //====================================================================== read in functions

  MOMS_type MOMS(parameters);
  MOMS.initialize();

  MOMS.read(parameters.get_directory() + parameters.get_output_file_name());

  //====================================================================== compute lattice chi

  if(false)
    {
      /*
      typedef DCA::coarsegraining_sp<parameters_type, k_DCA        > coarsegraining_sp_type;
      typedef DCA::lattice_map_sp   <parameters_type, k_DCA, k_HOST> lattice_map_sp_type;

      typedef DCA::cluster_solver<DCA::HIGH_TEMPERATURE_SERIES, LIN_ALG::CPU, parameters_type, MOMS_type> HTS_solver_type;

      coarsegraining_sp_type cluster_mapping_obj(parameters);
      lattice_map_sp_type    lattice_mapping_obj(parameters);

      MOMS.Sigma_lattice_interpolated  = 0.;
      MOMS.Sigma_lattice_coarsegrained = 0.;

      MOMS.Sigma_lattice = 0.;

      if(parameters.use_HTS_approximation())
        {
          MOMS_type MOMS_HTS(parameters);

          MOMS_HTS.H_HOST         = MOMS.H_HOST;
          MOMS_HTS.H_interactions = MOMS.H_interactions;

          HTS_solver_type HTS_solver(parameters, MOMS_HTS);

          lattice_mapping_obj.execute_with_HTS_approximation(MOMS_HTS, HTS_solver, cluster_mapping_obj,
                                                             MOMS.Sigma,
                                                             MOMS.Sigma_lattice_interpolated,
                                                             MOMS.Sigma_lattice_coarsegrained,
                                                             MOMS.Sigma_lattice);
        }
      else
        {
          lattice_mapping_obj.execute(MOMS.Sigma, MOMS.Sigma_lattice_interpolated, MOMS.Sigma_lattice_coarsegrained, MOMS.Sigma_lattice);
        }

      MOMS.compute_Sigma_bands();

      MOMS.write("data6_HTS.json");
      */

      /*
        DCA::coarsegraining_chi<parameters_type, k_HOST_VERTEX> coarsegraining_chi_obj(parameters);

        function<std::complex<double>, dmn_4<b_b, b_b, k_HOST_VERTEX, w_VERTEX> > phi("phi");

        phi.print_fingerprint();

        coarsegraining_chi_obj.execute(MOMS.H_HOST, MOMS.Sigma_lattice, phi);
      */
    }

  //====================================================================== compute lattice self-energy

  if(false)
    {
      /*
      compute_band_structure::execute(parameters, MOMS.H_LDA, MOMS.band_structure);

      MOMS.coarsegrain_inversion_obj.execute(MOMS.Sigma, MOMS.Sigma_lattice_interpolated,
                                             MOMS.Sigma_lattice_coarsegrained, MOMS.Sigma_lattice);

      MOMS.compute_Sigma_bands();
      */

      //       if(concurrency.id() == concurrency.last()){
      //        std::cout << "processor " << concurrency.id() << " is writing data " << endl;
      //        //       print_data::to_JSON(std::string("Sigma_band_structure.json"), parameters,
      //        //                        MOMS.band_structure, MOMS.Sigma_band_structure);
      //        //       print_data::to_JSON(std::string("Sigma_band_structure.json"), parameters,
      //        //                        MOMS.band_structure, MOMS.Sigma_lattice_band_structure);
      //        print_data::to_JSON(std::string("Sigma_band_structure.json"), parameters,
      //                            MOMS.band_structure, MOMS.Sigma_lattice);
      //       }
    }

  //====================================================================== series expansion of sigma
  /*
    if(false)
    {
    MOMS.initialize_functions(false);

    SERIES_EXPANSION::series_expansion<parameters_type, MOMS_type> series_exp_obj(parameters, MOMS);

    series_exp_obj.execute();

    print_data::to_JSON(parameters, series_exp_obj, ANALYSIS);
    }
  */

  //====================================================================== ED of Sigma
  /*
    if(false)
    {
    MOMS.initialize_functions(false);

    fermionic_Fock_space<b, s, r_DCA> Fock_obj;

    Fock_obj.compute_overlap();

    fermionic_Hamiltonian<parameters_type, b, s, r_DCA> Ham_obj(parameters, Fock_obj);

    function<std::complex<double>, dmn_3<nu,nu,r_DCA> > H_DCA;
    FT<k_DCA, r_DCA>::execute(MOMS.H_DCA, H_DCA);

    Ham_obj.initialize(H_DCA, MOMS.H_interactions);

    {
    Ham_obj.construct_Hamiltonians(false);

    Ham_obj.diagonolize_Hamiltonians();

    Ham_obj.generate_Greens_function(false);
    }

    {
    Ham_obj.construct_Hamiltonians(true);

    Ham_obj.diagonolize_Hamiltonians();

    Ham_obj.generate_Greens_function(true);
    }

    Ham_obj.compute_selfenergy();

    throw std::logic_error(__FUNCTION__);
    }
  */

  //====================================================================== analytic continuation to real axis
  /*
    if(parameters.do_CPE())
    {
    //compute_spectrum<parameters_type, union_radial_and_delta_function, TETRAHEDRON_INTEGRATION, LEVMAR_LIBRARY>  CS_obj(parameters);
    //compute_spectrum<parameters_type, radial_function                , TETRAHEDRON_INTEGRATION, GRADIENT_METHOD> CS_obj(parameters, MOMS);

    compute_spectrum<parameters_type, piece_wise_linear_function, TETRAHEDRON_INTEGRATION, GRADIENT_METHOD> CS_obj(parameters, MOMS);
    CS_obj.execute(MOMS.H_LDA, MOMS.Sigma);

    if (concurrency.id() == concurrency.last()){
    cout << "processor " << concurrency.id() << " is writing data " << endl;
    print_data::to_JSON(parameters.get_output_spectrum_file_name(), parameters, CS_obj, ANALYSIS);
    }
    }
  */

  if(parameters.do_CPE())
    {
      std::string data_file_ED  = parameters.get_directory()+parameters.get_ED_output_file_name();
      std::string data_file_CPE = parameters.get_directory() + parameters.get_spectrum_file_name();

      DCA::compute_spectrum<parameters_type, DCA::piece_wise_linear_function> CS_obj(parameters);

      MOMS_w_real<parameters_type> MOMS_real(parameters);

      bool data_file_ED_exists = file_exists(data_file_ED);
      if(false and data_file_ED_exists)
	{
          MOMS_real.read(data_file_ED);
	  
	  // reset the interacting fucntions
	  MOMS_real.Sigma = 0;
	  MOMS_real.G_k_w = 0;
	  
	  MOMS_real.G_k_w = 0;
	  MOMS_real.G_r_w = 0;
	  
	  MOMS_real.A_w    = 0;
	  MOMS_real.A_nu_w = 0;
	}
      
      CS_obj.execute(MOMS, MOMS_real);

      if(concurrency.id() == concurrency.last())
        CS_obj.write(data_file_CPE, MOMS, MOMS_real);
    }

  //====================================================================== compute susceptibility

  if(parameters.get_vertex_measurement_type() != NONE)
    {
      //dca::analysis<parameters_type, MOMS_type, CT_AUX> analysis_obj(parameters, MOMS);

      //dca::analysis<parameters_type, MOMS_type, ANALYSIS_INTERPOLATION> analysis_obj(parameters, MOMS);

      DCA::BSE_solver<parameters_type, MOMS_type> analysis_obj(parameters, MOMS);
      
      analysis_obj.calculate_susceptibilities_2();
      
      if(concurrency.id() == concurrency.last()){
        cout << "processor " << concurrency.id() << " is writing data " << endl;
        analysis_obj.write();
        //print_data::to_JSON(parameters, analysis_obj, MC_ALGORITHM_TYPE);
      }
    }

  if(concurrency.id() == concurrency.last())
    parameters_type::profiler_type::stop(parameters.get_profiling_file_name());

  if(concurrency.id() == concurrency.last())
    cout << "\n\tanalysis: ending.\n";

  return 0;
}

