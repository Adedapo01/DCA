//-*-C++-*-

/*
________  _________     _____                                             
\______ \ \_   ___ \   /  _  \      .__                                   
 |    |  \/    \  \/  /  /_\  \   __|  |___                               
 |    `   \     \____/    |    \ /__    __/                               
/_______  /\______  /\____|__  /    |__|                                  
        \/        \/         \/                                           

__________        __                   _________ __                       
\______   \ _____/  |_  ___________   /   _____//  |______  _____ _______ 
 |     ___// __ \   __\/ __ \_  __ \  \_____  \\   __\__  \ \__  \\_  __ \
 |    |   \  ___/|  | \  ___/|  | \/  /        \|  |  / __ \_/ __ \|  | \/
 |____|    \___  >__|  \___  >__|    /_______  /|__| (____  (____  /__|   
               \/          \/                \/           \/     \/       
_________________________ ___   __________            .__       .__       
\_   _____/\__    ___/   |   \  \____    /__ _________|__| ____ |  |__    
 |    __)_   |    | /    ~    \   /     /|  |  \_  __ \  |/ ___\|  |  \   
 |        \  |    | \    Y    /  /     /_|  |  /|  | \/  \  \___|   Y  \  
/_______  /  |____|  \___|_  /  /_______ \____/ |__|  |__|\___  >___|  /  
        \/                 \/           \/                    \/     \/   
 */

#include "compiler_directives.h"

#include "include_files.h"

std::string get_version()
{
  string str("DEFAULT");
  return str;
}

void print_version()
{
  string str = get_version();
 
  cout << "\n\n\n";
  cout << "*************************************************************************************\n";
  cout << "***                                  VERSION                                      ***\n";
  cout << "*************************************************************************************\n";
  cout << "\n\n\n";
 
  cout << str << endl;
}

void synchronize_devices(){}

int main(int argc,char *argv[])
{
  if (argc < 2) {
    std::cout << "Usage: "<<argv[0]<<" inputFileName\n";
    return -1;
  }

  std::string file_name(argv[1]);

  //============================================================ Configure the calculation by selecting type definitions.


  static const MPI_library_type           MPI_LIBRARY_TYPE  = MPI_LIBRARY;
  static const MC_integration_method_type MC_ALGORITHM_TYPE = MC_ALG_TYPE;

  typedef concurrency<MPI_LIBRARY_TYPE>    concurrency_type;
  
  typedef Parameters<concurrency_type, model, MC_ALGORITHM_TYPE> parameters_type;
  
  typedef MultiOrbitalMultiSiteStructure<parameters_type, DCA_cluster_type> MOMS_type;

  //====================================================================== Create the algorithms and parameters object from the input file

  concurrency_type& concurrency(concurrency_type::get(argc,argv,"logFile"));
  concurrency << "DCA main: starting (MPI-world set up).\n\n";

  std::string stamp = get_version();
  if(concurrency.id() == concurrency.first()){
    print_version();
    provenance<interaction_type, model, MC_ALGORITHM_TYPE, MPI_LIBRARY_TYPE>::print_on_shell(QMC_INTEGRATOR_BIT);
  }

  parameters_type parameters(get_version(), concurrency);
  
  parameters.read_input_and_broadcast(file_name);

  parameters.update_model();
  parameters.update_domains();

  //====================================================================== read in functions

  MOMS_type MOMS(parameters);

  MOMS.from_JSON();

  //====================================================================== compute lattice self-energy
  /*
  if(false)
    {
      compute_band_structure::execute(parameters, MOMS.H_LDA, MOMS.band_structure);
      
      MOMS.coarsegrain_inversion_obj.execute(MOMS.Sigma, MOMS.Sigma_lattice_interpolated,
					     MOMS.Sigma_lattice_coarsegrained, MOMS.Sigma_lattice);    
      
      MOMS.compute_Sigma_bands();
      
      if(concurrency.id() == concurrency.last()){
	std::cout << "processor " << concurrency.id() << " is writing data " << endl;
	//       print_data::to_JSON(std::string("Sigma_band_structure.json"), parameters, 
	// 			  MOMS.band_structure, MOMS.Sigma_band_structure);
	//       print_data::to_JSON(std::string("Sigma_band_structure.json"), parameters, 
	// 			  MOMS.band_structure, MOMS.Sigma_lattice_band_structure);
	print_data::to_JSON(std::string("Sigma_band_structure.json"), parameters, 
			    MOMS.band_structure, MOMS.Sigma_lattice);
      }
    }
  */

  //====================================================================== series expansion of sigma
  /*
  if(false)
    {
      MOMS.initialize_functions(false);
      
      SERIES_EXPANSION::series_expansion<parameters_type, MOMS_type> series_exp_obj(parameters, MOMS);
      
      series_exp_obj.execute();
      
      print_data::to_JSON(parameters, series_exp_obj, ANALYSIS);
    }
  */

  //====================================================================== ED of Sigma
  /*
  if(false)
    {
      MOMS.initialize_functions(false);

      fermionic_Fock_space<b, s, r_DCA> Fock_obj;
      
      Fock_obj.compute_overlap();

      fermionic_Hamiltonian<parameters_type, b, s, r_DCA> Ham_obj(parameters, Fock_obj);
      
      function<std::complex<double>, dmn_3<nu,nu,r_DCA> > H_DCA;
      FT<k_DCA, r_DCA>::execute(MOMS.H_DCA, H_DCA);
      
      Ham_obj.initialize(H_DCA, MOMS.H_interactions);
      
      {
	Ham_obj.construct_Hamiltonians(false);
	
	Ham_obj.diagonolize_Hamiltonians();
	
	Ham_obj.generate_Greens_function(false);
      }

      {
	Ham_obj.construct_Hamiltonians(true);
	
	Ham_obj.diagonolize_Hamiltonians();

	Ham_obj.generate_Greens_function(true);
      }

      Ham_obj.compute_selfenergy();

       throw std::logic_error(__FUNCTION__);
    }
  */

  //====================================================================== analytic continuation to real axis
/*
  if(parameters.do_CPE())
    {
      //compute_spectrum<parameters_type, union_radial_and_delta_function, TETRAHEDRON_INTEGRATION, LEVMAR_LIBRARY> CS_obj(parameters);
      //compute_spectrum<parameters_type, radial_function, TETRAHEDRON_INTEGRATION, GRADIENT_METHOD> CS_obj(parameters, MOMS);
      compute_spectrum<parameters_type, piece_wise_linear_function, TETRAHEDRON_INTEGRATION, GRADIENT_METHOD> CS_obj(parameters, MOMS);
      CS_obj.execute(MOMS.H_LDA, MOMS.Sigma);

      if (concurrency.id() == concurrency.last()){
	cout << "processor " << concurrency.id() << " is writing data " << endl;
	print_data::to_JSON(parameters, CS_obj, ANALYSIS);
      }
    }
*/
  //====================================================================== compute susceptibility

  if(parameters.get_vertex_measurement_type() != NONE)
    {
      //dca::analysis<parameters_type, MOMS_type, CT_AUX> analysis_obj(parameters, MOMS);
      dca::analysis<parameters_type, MOMS_type, ANALYSIS_INTERPOLATION> analysis_obj(parameters, MOMS);
    
      analysis_obj.calculate_susceptibilities();
      
      if(concurrency.id() == concurrency.last()){
	cout << "processor " << concurrency.id() << " is writing data " << endl;
	print_data::to_JSON(parameters.get_output_susceptibilities_file_name(), 
			    parameters, analysis_obj, MC_ALGORITHM_TYPE);
      }
    }
  
  if(concurrency.id() == concurrency.last())
    parameters_type::profiler_type::stop(parameters.get_profiling_file_name());
  
  concurrency << "\n\tanalysis: ending.\n";
  
  return 0;
}

