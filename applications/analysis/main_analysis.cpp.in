// Copyright (C) 2009-2016 ETH Zurich
// Copyright (C) 2007?-2016 Center for Nanophase Materials Sciences, ORNL
// All rights reserved.
//
// See LICENSE.txt for terms of usage.
// See CITATION.txt for citation guidelines if you use this code for scientific publications.
//
// Author: Peter Staar (peter.w.j.staar@gmail.com)
//         Urs R. Haehner (haehneru@itp.phys.ethz.ch)
//
// Main file for the DCA(+) analysis.
// Usage: ./main_analysis input_file.json

#include <iostream>
#include <string>

#include "dca/config/defines.hpp"
#include "gitVersion.hpp"
#include "modules.hpp"

#include "tight_binding_on_2D_square_lattice.hpp"

#include "dca/concurrency/concurrency.hpp"
#include "comp_library/IO_library/JSON/JSON.hpp"
#include "phys_library/DCA+_analysis/BSE_solver/BSE_solver.h"
#include "phys_library/DCA+_data/DCA_data.h"
#include "phys_library/parameters/Parameters.h"

using namespace DCA;  // TODO: Remove when all namespaces are fixed.

int main(int argc, char** argv) {
  if (argc < 2) {
    std::cout << "Usage: " << argv[0] << " input_file.json" << std::endl;
    return -1;
  }

  std::string input_file_name(argv[1]);

  // Configure the DCA(+) calculation by selecting type definitions.
  using ConcurrencyType = dca::concurrency::parallelization<@DCA_PARALLELIZATION_LIBRARY_TYPE@>;
  // CT_AUX_CLUSTER_SOLVER is just a dummy variable when running the analysis.
  using ParametersType =
      Parameters<ConcurrencyType, ModelType, void /*RngType*/, CT_AUX_CLUSTER_SOLVER>;
  using DcaDataType = DCA_data<ParametersType>;

  // Set up the parallelization.
  ConcurrencyType concurrency(argc, argv);

  // Print some info.
  if (concurrency.id() == concurrency.first()) {
    std::cout << "\nAnalysis starting.\n"
              << "MPI-world set up: " << concurrency.number_of_processors() << " processes.\n"
              << std::endl;

    GitVersion::print();
    Modules::print();
  }

  // Create the parameters object from the input file.
  ParametersType parameters(GitVersion::string(), concurrency);
  parameters.read_input_and_broadcast<IO::reader<IO::JSON>>(input_file_name);
  parameters.update_model();
  parameters.update_domains();

  // Create and initialize the DCA_data object and read the dca output.
  DcaDataType dca_data(parameters);
  dca_data.initialize();
  dca_data.read(parameters.get_directory() + parameters.get_output_file_name());

  // Compute the susceptibility.
  if (parameters.get_vertex_measurement_type() != NONE) {
    BSE_solver<ParametersType, DcaDataType> analysis_obj(parameters, dca_data);

    analysis_obj.calculate_susceptibilities_2();

    if (concurrency.id() == concurrency.last()) {
      std::cout << "\nProcessor " << concurrency.id() << " is writing data " << std::endl;
      analysis_obj.write();
    }
  }

  if (concurrency.id() == concurrency.last())
    std::cout << "\nAnalysis ending.\n" << std::endl;

  return 0;
}
