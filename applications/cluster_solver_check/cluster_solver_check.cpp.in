//====================================================================
// Copyright 2013-2016 ETH Zurich.
//
// First solves the cluster problem by exact diagonalization and then
// using QMC.
//
// Usage: ./cluster_solver_check inputFileName
//
// Authors: Peter Staar (taa@zurich.ibm.com), IBM Research - Zurich
//          Urs Haehner (haehneru@itp.phys.ethz.ch), ETH Zurich
//====================================================================

#include <string>
#include <iostream>

#include "gitVersion.hpp"
#include "modules.hpp"
#include "include_files.h"

using namespace DCA;

int main(int argc, char *argv[]) {
  if (argc < 2) {
    std::cerr << "Usage: " << argv[0] << " inputFileName" << std::endl;
    return -1;
  }

  std::string file_name(argv[1]);

  using concurrency_type = COMP_LIB::parallelization<@DCA_PARALLELIZATION_LIBRARY_TYPE@>;
  using parameters_type = Parameters<concurrency_type, model, @DCA_CLUSTER_SOLVER_TYPE@>;
  using MOMS_type = DCA_data<parameters_type>;
  using ED_solver_type =
      cluster_solver<ADVANCED_ED_CLUSTER_SOLVER, @DCA_LIN_ALG_DEVICE_TYPE@,
                     parameters_type, MOMS_type>;
  using quantum_cluster_solver_type =
    cluster_solver<@DCA_CLUSTER_SOLVER_TYPE@, @DCA_LIN_ALG_DEVICE_TYPE@,
                   parameters_type, MOMS_type>;
  using QMC_solver_type = @DCA_MC_INTEGRATOR_TYPE@;

  // Setup the parallelization.
  concurrency_type concurrency(argc, argv);

  parameters_type::profiler_type::start();

  // Print some info.
  if (concurrency.id() == concurrency.first()) {
    std::cout << "\nCluster-solver-check starting.\n"
              << "MPI-world set up: " << concurrency.number_of_processors()
              << " processes.\n" << std::endl;

    GitVersion::print();
    Modules::print();
  }

  // Create the parameters object from the input file.
  parameters_type parameters(GitVersion::string(), concurrency);
  parameters.read_input_and_broadcast(file_name);
  parameters.update_model();
  parameters.update_domains();

  DCA_calculation_data DCA_info_struct;

  // Create and initialize the DCA_data objects.
  MOMS_type MOMS_imag(parameters);
  MOMS_imag.initialize();
  MOMS_w_real<parameters_type> MOMS_real(parameters);

  std::string data_file_ED =
      parameters.get_directory() + parameters.get_ED_output_file_name();
  std::string data_file_QMC =
      parameters.get_directory() + parameters.get_QMC_output_file_name();

  // ED solver
  ED_solver_type ED_obj(parameters, MOMS_imag, MOMS_real);
  ED_obj.initialize(0);
  ED_obj.execute();
  ED_obj.finalize(DCA_info_struct);

  FUNC_LIB::function<std::complex<double>, dmn_4<nu,nu,k_DCA,w> > Sigma_ED(MOMS_imag.Sigma);
  
  if (concurrency.id() == concurrency.first()) {
    ED_obj.write(data_file_ED);
  }

  // QMC solver
  // The QMC solver uses the free Greens function G0 computed by the ED solver.
  // It is passed via the MOMS_imag object.
  QMC_solver_type QMC_obj(parameters, MOMS_imag);
  QMC_obj.initialize(1);
  QMC_obj.integrate();
  QMC_obj.finalize(DCA_info_struct);

  FUNC_LIB::function<std::complex<double>, dmn_4<nu,nu,k_DCA,w> > Sigma_QMC(MOMS_imag.Sigma);
  
  if (concurrency.id() == concurrency.first()) {
    MOMS_imag.write(data_file_QMC);
  }

  // Check errors
  if (concurrency.id() == concurrency.first()) {
    double max_absolute_diff = 0;
    double max_relative_diff = 0;

    std::cout << "\n\nErrors\n"
              << "b1\tb2\ts1\ts2\tK\t|Sigma_ED - Sigma_QMC|_inf\t|Sigma_ED - Sigma_QMC|_inf / |Sigma_ED|_inf" << std::endl;
    for (int b1 = 0; b1 < b::dmn_size(); ++b1) {
      for (int b2 = 0; b2 < b::dmn_size(); ++b2) {
        for (int s1 = 0; s1 < s::dmn_size(); ++s1) {
          for (int s2 = 0; s2 < s::dmn_size(); ++s2) {
            for (int k_ind = 0; k_ind < k_DCA::dmn_size(); ++k_ind) {
              
              double ED_min_QMC_inf = 0.;
              double ED_inf = 0.;
              for (int w_ind = 0; w_ind < w::dmn_size(); ++w_ind) {
                ED_min_QMC_inf = std::max(ED_min_QMC_inf, std::abs(Sigma_ED(b1, s1, b2, s2, k_ind, w_ind)
                                                                   - Sigma_QMC(b1, s1, b2, s2, k_ind, w_ind)));
                ED_inf = std::max(ED_inf, std::abs(Sigma_ED(b1, s1, b2, s2,  k_ind, w_ind)));
                max_absolute_diff = std::max(max_absolute_diff, ED_min_QMC_inf);
                max_relative_diff = std::max(max_relative_diff, ED_min_QMC_inf/ED_inf);
              }
              std::cout << b1 << "\t" << b2 << "\t" << s1 << "\t" << s2 << "\t" << k_ind << "\t" << ED_min_QMC_inf << "\t\t\t" << ED_min_QMC_inf/ED_inf << std::endl;
            }
          }
        }
      }
    }

    std::cout << "\n|(Sigma_ED - Sigma_QMC)|_inf          = " << max_absolute_diff
              << "\n|(Sigma_ED - Sigma_QMC)/Sigma_ED|_inf = " << max_relative_diff << std::endl;
  }
  
  parameters_type::profiler_type::stop(concurrency,
                                       parameters.get_profiling_file_name());
  
  if (concurrency.id() == concurrency.first())
    std::cout << "\nCheck ending.\n" << std::endl;

  return 0;
}
